[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "POWFACPY",
    "section": "",
    "text": "powfacpy is a wrapper around the Python API of PowerFactory |copy| (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory |copy| with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory |copy| database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\n   set_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path “Network Mod…”.\nPlotting also requires many lines with the native API (need to add the variable to the monitored variables, create a plot page, add the curve,..). However, using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\n   set_active_plot(\"Active power\",\"§ PV plant\")\n   plot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the :ref:tutorials or see a list of classes and methods under :ref:api.\nThe module is at an early stage. Contributions (new features, bug reports, feature requests, etc.) are very welcome on Github."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "POWFACPY",
    "section": "",
    "text": "powfacpy is a wrapper around the Python API of PowerFactory |copy| (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory |copy| with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory |copy| database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\n   set_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path “Network Mod…”.\nPlotting also requires many lines with the native API (need to add the variable to the monitored variables, create a plot page, add the curve,..). However, using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\n   set_active_plot(\"Active power\",\"§ PV plant\")\n   plot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the :ref:tutorials or see a list of classes and methods under :ref:api.\nThe module is at an early stage. Contributions (new features, bug reports, feature requests, etc.) are very welcome on Github."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "POWFACPY",
    "section": "Installation",
    "text": "Installation\nUsing pip:\n   pip install powfacpy"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "POWFACPY",
    "section": "Contact",
    "text": "Contact\nsimon.eberlein@iee.fraunhofer.de"
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "POWFACPY",
    "section": "About",
    "text": "About\nThis module is under active development.\npowfacpy is an open source module which is mainly developed at Fraunhofer IEE and not associated with DIgSILENT.\n\nNext -&gt;"
  },
  {
    "objectID": "docs/tutorials/study_cases.html",
    "href": "docs/tutorials/study_cases.html",
    "title": "Study cases",
    "section": "",
    "text": "Parameter studies are organized in study cases, operation scenarios and variations in PowerFactory. This tutorials shows how to create parameter studies with ease and fully automated using the study cases interface of powfacpy.\nFirst, we activate the PowerFactory project as in the getting started tutorial.\n\n\nCode\n# If you use IPython/Jupyter:\nimport sys\nsys.path.append(r'C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.10') # you may use a different directory\n# Get the PF app\nimport powerfactory\napp = powerfactory.GetApplication()\nimport powfacpy\napp.Show()\napp.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path.\n\n\n\nSimple Parameter Study\nWe use the class PFStudyCases. This class inherits from PFBaseInterface, so all methods from that class are available. We want to create study case with various values for the active and reactive power of a load.\nFirst we set the attribute parameter_values and define a dictionary with parameter names and a list of values. Each element in the lists is used in one study case.\n\n\nCode\npfsc = powfacpy.PFStudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":[ 1,  2, 1, 2],\n    \"q HV load\":[-1, -1, 1, 1],\n}\n\n\nHere we have defined four study cases and in the first case p HV load equals 1 and q HV load equals -1. The parameter names must not contain *?=“,~|()! as these characters cannot be used for names of objects in PF.\nNext we connect the variables to the PF database by defining a dictionary with paths in the attribute parameter_paths using the same parameter names as keys. The paths include the attribute name (e.g. plini which is the active power of the load).\n\n\nCode\npfsc.parameter_paths = {\n    \"p HV load\":r\"Network Model\\Network Data\"\n        r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\", # This is one string split over several lines\n    \"q HV load\":r\"Network Model\\Network Data\"\n        r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\n\n\nFinally we define the active grids. For now, we assume that for all cases exactly one grid is active (we look at more complicated cases later).\n\n\nCode\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\n\nNow let’s create the study cases.\n\n\nCode\npfsc.create_cases()\n\n\nThis creates the following study cases:\n\nThe names of the study cases are created according to the parameter names and their values (“_” is used instead of “=” which is not allowed in PF object names). Furthermore, the corresponding operation scenarios are created:\n\nFor more complicated case studies with further parameters, it is advisable to structure the cases in folders. We define the attribute hierarchy using a list of parameter names (in this case with only one element) that corresponds to folder directories.\n\n\nCode\npfsc.hierarchy = [\"q HV load\", \"p HV load\"]\npfsc.create_cases()\n\n\nNow q HV load is used for the folder names and not in the study case name.\n\nThe structure of the operation scenarios is similar.\n\n\nAdvanced Parameter Study\nLet’s take a look at a more complex parameter study.\n\n\nCode\npfsc = powfacpy.PFStudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":[1, 2, 1, 2, 1, 2, 1, 2, ],\n    \"q HV load\":[-1, -1, 1, 1, -1, -1, 1, 1, ],\n    \"control\": [\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", ]\n}\npfsc.parameter_paths = {\n    \"p HV load\":r\"Network Model\\Network Data\"\n        r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\", \n\n    \"q HV load\":r\"Network Model\\Network Data\"\n        r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\", \n\n}\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\n\nAn additional parameter control is defined. Note that there is no parameter path defined for this parameter. The parameter can be seen as a placeholder for the study cases structure and to do more complicated things than simply setting an attribute of a PF object later (we’ll see below).\nBy default, study cases and operation scenarios are created. If variations should be created in addition, use:\n\n\nCode\npfsc.add_variation_to_each_case = True\n\n\nThis can be necessary because some parameters, like attributes of DSL objects, are stored in variants and not in operation scenarios. Let’s again create the study cases.\n\n\nCode\npfsc.hierarchy = [\"control\", \"q HV load\"]\npfsc.create_cases()\n\n\nThis creates the following structure in the network variations (as well as in the scenarios and study cases):\n\nLet’s set further parameters, add plots (using plot interface) and simulate (using dyn. simulation interface) for each study case. The study case objects are stored in the study_cases attribute. We can iterate through the cases and set parameters depending on the previously defined control parameter.\n\n\nCode\npfpi = powfacpy.PFPlotInterface(app)\npfds = powfacpy.PFDynSimInterface(app)\ndsl_controller_obj = pfsc.get_unique_obj(r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\")\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    study_case_obj.Activate()\n    # Set controller parameters\n    if pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"A\":\n        pfsc.set_attr(dsl_controller_obj, {\"PfFlag\":0, \"VFlag\":1}) \n    elif pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"B\":\n        pfsc.set_attr(dsl_controller_obj, {\"PfFlag\":1, \"VFlag\":0}) \n    # Prepare plots\n    pfpi.clear_plot_pages()\n    pfpi.set_active_plot(\"Reactive current\", \"WPP\")\n    pfpi.plot(dsl_controller_obj, \"s:Iqcmd\")\n    # Simulate   \n    pfds.initialize_and_run_sim() \n\n\nLet’s walk through this piece of code. The plotting and simulation interfaces are instantiated and a DSL object is assigned to be used later.\nIt is iterated through the study cases objects (and case numbers) and each study case is activated. Then the controller parameters are set. The value of the control parameter is obtained using the method get_value_of_parameter_for_case and the controller parameters are set depending on the controller type (A or B). This provides the flexibility to adjust the study cases depending on previously defined parameters in any way (e.g. set parameters, activate grids, …). And all settings are stored in the previously defined operation scenarios/variations.\nFinally, a plot is created for every case and the dynamic simulation is executed.\n\n\nCompare Study Cases\nIt is often required to compare the results of cases. In the following, we use the previously defined cases to compare the simulation results for cases where the parameter p HV load equals 1 (note that you may have to “Rebuild”  the plot in the upper left for PF to show it correctly):\n\n\nCode\n# Create a study case where results from other cases are compared in a plot\nstudy_case_comparison = pfsc.create_by_path(r\"Study Cases\\Comparison.IntCase\")\nstudy_case_comparison.Activate()\npfpi.clear_plot_pages()\npfpi.set_active_plot(\"Reactive current controller setpoint for p HV load = 1\", \"Comparison \")\ndsl_controller_obj = (r\"Network Model\\Network Data\\test_case_studies\" \n    r\"\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\")\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):  \n    if pfsc.get_value_of_parameter_for_case(\"p HV load\", case_num) == 1:\n        # Get results object from respective study case \n        results_obj = pfsc.get_unique_obj(\n            \"*.ElmRes\", parent_folder=study_case_obj)\n        # Create label for plot\n        case_label = pfsc.get_case_params_value_string(case_num,\n            omitted_parameters=\"p HV load\",\n            delimiter=\" | \",\n            equals_sign=\"=\") \n        label = \"Iq setpoint (\" + case_label + \")\"\n        # Plot\n        pfpi.plot(dsl_controller_obj, \"s:Iqcmd\",\n            results_obj=results_obj,\n            label=label)\n\n\nThis creates a plot with legend:\n\nLet’s walk through the code. After creating a study case where the results are compared in a plot, it is again iterated through all cases. For cases where p HV load has a certain value, the result object is fetched. Next we want to create a label for the curve in the plot. We use the method get_case_params_value_string with certain options for the delimiter and the equals symbol (here we have more options than for PF object names, i.e. = and | are allowed). Moreover, the parameter p HV load is omitted because it is the same for all compared cases (i.e. 1, see condition). Further information on the variable is added to the label and the curve is finally added to the plot.\nAn alternative to iterating through all study cases is to get certain cases using the method get_study_cases:\n\n\nCode\nstudy_cases_p_HV_load_equals_1 = pfsc.get_study_cases({\"p HV load\":lambda x: x==1})\nfor study_case_obj in study_cases_p_HV_load_equals_1:\n    pass\n    # do something with the specific cases\n\n\nget_study_cases takes a dictionary as input, where lambda functions with conditions for parameters are defined. Note that the methods get_value_of_parameter_for_case and get_case_params_value_string also work with study case objects as inputs instead of case numbers.\nA very convenient yet powerful alternative to ‘get_study_cases’ especially for complicated conditionals is ‘get_study_cases_from_string’. This method simply accepts a string which can contain complicated conditionals:\n\n\nCode\nstudy_cases_from_conditionals = pfsc.get_study_cases_from_string(\n    \"p HV load &gt;= 2 and (control == 'A' or q HV load != 1\")\n\n\nThat makes it very easy to plot and compare certain cases.\n\n\nPermutation\nIt is also possible to create study cases for the permutation of the parameters (i.e. all combinations). This is achieved with the method apply_permutation. Define the parameter values first (and also the hierarchy if applicable) and then call the method. Make sure that the PF application is hidden to improve the performance (if not hidden, this can take minutes and otherwise only seconds):\n\n\nCode\npfsc.app.Hide()\npfsc.parameter_values = {\n        \"p HV load\":[1, 2, 3],\n        \"q HV load\":[-1, 1],\n        \"control 1\": [\"A\", \"B\"],\n        \"control 2\": [\"R\", \"S\"],\n    }\npfsc.hierarchy = [\"p HV load\", \"control 1\", ]\npfsc.apply_permutation()\npfsc.create_cases()\npfsc.app.Show()\n\n\napply_permutation irreversibly replaces the values in parameter_values with the permutation.\nIt may be desirable to use the permutation but omit certain combinations. These omitted combinations can be defined in a list of dictionaries and used as a keyword argument as follows:\n\n\nCode\nomitted_combinations = [\n    {\"q HV load\": [1, 0], \"control 2\": [\"R\", \"T\"]},\n    {\"p HV load\": [2], \"control 1\": \"all\", \"control 2\": \"all\"},\n]\npfsc.apply_permutation(omitted_combinations=omitted_combinations)\n\n\nThe first dictionary causes any combinations where “q HV load” is 1 or 0 and “control 2” is either “R” or “T” to be omitted (these cases will not be created when create_cases is called). In the second dictionary, the keyword “all” is used. This means that all combinations with this parameter are omitted.\n\n\nFurther functionality\nThe attributes of PFStudyCases instances allow to set further options. The folders in which the study cases/operation scenarios/variations are ceated can be set using the attributes parent_folder_study_cases/parent_folder_scenarios/parent_folder_variations. The study case names can be numbered consecutively setting consecutively_number_case_names. Sometimes it is convenient to use only parameter values without the parameter names for the folder/study case names (imagine the value of a parameter is expressive enough and you don’t want to use “Controller_GridCode2012Controller” but only “GridCode2012Controller” instead). This can be achieved by adding parameters to the list of anonymous_parameters (e.g. pfsc.anonymous_parameters=[\"Controller\",\"FurtherParName\"]).\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Study cases"
    ]
  },
  {
    "objectID": "docs/tutorials/tutorials.html",
    "href": "docs/tutorials/tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "The tutorials are Jupyter notebooks which you can find in the Tutorials section.\nYou can use the PowerFactory project ‘powfacpy_tests’ from here &lt;https://github.com/FraunhIEE-UniKassel-PowSysStability/powfacpy/tree/main/powerfactory_projects&gt;_ to run the commands in the tutorials locally.",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "docs/tutorials/tutorials.html#getting-started",
    "href": "docs/tutorials/tutorials.html#getting-started",
    "title": "Tutorials",
    "section": "Getting started",
    "text": "Getting started\nStart here with the Getting started with Powfacpy section . This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code.",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "docs/tutorials/tutorials.html#dynamic-simulation-and-plotting",
    "href": "docs/tutorials/tutorials.html#dynamic-simulation-and-plotting",
    "title": "Tutorials",
    "section": "Dynamic Simulation and Plotting",
    "text": "Dynamic Simulation and Plotting\nThe Dynamic Simulation and Plotting section shows how to conveniently simulate and plot with a syntax similar to matplotlib. It is also depicted how to export data to csv format and use external plotting libraries such as matplotlib.",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "docs/tutorials/tutorials.html#study-cases",
    "href": "docs/tutorials/tutorials.html#study-cases",
    "title": "Tutorials",
    "section": "Study Cases",
    "text": "Study Cases\nThe Study Case section provides a flexible method to automatically create study cases from different data.",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "docs/api/database_interface.PFDatabaseInterface.html",
    "href": "docs/api/database_interface.PFDatabaseInterface.html",
    "title": "database_interface.PFDatabaseInterface",
    "section": "",
    "text": "database_interface.PFDatabaseInterface(self, app)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_object_attributes\nGet dictionary with attributes of objects.\n\n\nset_object_attributes\nTakes a dict with keys (object paths) and values (dict with attributes\n\n\n\n\n\ndatabase_interface.PFDatabaseInterface.get_object_attributes(objs, class_attributes=None, truncated_path='', pf_obj_handling='path')\nGet dictionary with attributes of objects. The keys of the dictionary are the paths of the objects. The values are dictionaries with keys (attribute names) and values (attribute values), see “example return dict” below.\nArguments: - objs: Iterable with PF objects - class_attributes: dictionary with keys (class names) and values (iterable with attribute names). To control which attributes are relevant for a class. The class names can contain wildcards (“”). Example: { ”ElmTr2”: [”typ_id”], ””: [“loc_name”, ], “ElmVac”: [“bus1”, “outserv”],\n} -&gt; “loc_name” is relevant for every class - truncated_path: If specified, this path is truncated from the keys (object paths) Example: truncated_path = “Network ModelData” -&gt; Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetVoltage Source.ElmVac” becomes “test_database_interface.ElmNetVoltage Source.ElmVac” (first part truncated) - pf_obj_handling: If the value of an attribute is a PF object, there are several options on how to read the attribute (please see _handle_attribute_type_for_reading)\nExample return dict: { “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetVoltage Source.ElmVac”: { “loc_name”: “AC Voltage Source”, “bus1”: “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetHV 1.ElmTerm_1.StaCubic”, “outserv”: 0 }, “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetHV 1.ElmTerm_1.StaCubic”: { “loc_name”: “Cub_1” }, }\n\n\n\ndatabase_interface.PFDatabaseInterface.set_object_attributes(obj_attr_dict, added_path='')\nTakes a dict with keys (object paths) and values (dict with attributes and their values) and writes the data to the PF database. (the dict can be created e.g. with ‘get_object_attributes’)\nArguments: - obj_attr_dict: data - added_path: Assumes that the object paths are relative to a parent folder inside the project. Adds added_path to the paths."
  },
  {
    "objectID": "docs/api/database_interface.PFDatabaseInterface.html#methods",
    "href": "docs/api/database_interface.PFDatabaseInterface.html#methods",
    "title": "database_interface.PFDatabaseInterface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_object_attributes\nGet dictionary with attributes of objects.\n\n\nset_object_attributes\nTakes a dict with keys (object paths) and values (dict with attributes\n\n\n\n\n\ndatabase_interface.PFDatabaseInterface.get_object_attributes(objs, class_attributes=None, truncated_path='', pf_obj_handling='path')\nGet dictionary with attributes of objects. The keys of the dictionary are the paths of the objects. The values are dictionaries with keys (attribute names) and values (attribute values), see “example return dict” below.\nArguments: - objs: Iterable with PF objects - class_attributes: dictionary with keys (class names) and values (iterable with attribute names). To control which attributes are relevant for a class. The class names can contain wildcards (“”). Example: { ”ElmTr2”: [”typ_id”], ””: [“loc_name”, ], “ElmVac”: [“bus1”, “outserv”],\n} -&gt; “loc_name” is relevant for every class - truncated_path: If specified, this path is truncated from the keys (object paths) Example: truncated_path = “Network ModelData” -&gt; Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetVoltage Source.ElmVac” becomes “test_database_interface.ElmNetVoltage Source.ElmVac” (first part truncated) - pf_obj_handling: If the value of an attribute is a PF object, there are several options on how to read the attribute (please see _handle_attribute_type_for_reading)\nExample return dict: { “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetVoltage Source.ElmVac”: { “loc_name”: “AC Voltage Source”, “bus1”: “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetHV 1.ElmTerm_1.StaCubic”, “outserv”: 0 }, “Network Model.IntPrjfolderData.IntPrjfolder_database_interface.ElmNetHV 1.ElmTerm_1.StaCubic”: { “loc_name”: “Cub_1” }, }\n\n\n\ndatabase_interface.PFDatabaseInterface.set_object_attributes(obj_attr_dict, added_path='')\nTakes a dict with keys (object paths) and values (dict with attributes and their values) and writes the data to the PF database. (the dict can be created e.g. with ‘get_object_attributes’)\nArguments: - obj_attr_dict: data - added_path: Assumes that the object paths are relative to a parent folder inside the project. Adds added_path to the paths."
  },
  {
    "objectID": "docs/api/dyn_sim_interface.PFDynSimInterface.html",
    "href": "docs/api/dyn_sim_interface.PFDynSimInterface.html",
    "title": "dyn_sim_interface.PFDynSimInterface",
    "section": "",
    "text": "dyn_sim_interface.PFDynSimInterface(self, app)\nDynamic simulation interface\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_dyn_sim_event\nCreates an event for dynamic simulations (RMS/EMT) and sets the parameters in ‘params’.\n\n\ncreate_event\nCreates an event and sets the parameters in ‘params’.\n\n\nget_dsl_model_parameter_names\nGet the parameter names of the block definition (BlkDef)\n\n\nget_dsl_obj_array\nGet the array of DSL object (‘Advanced 1’ tab).\n\n\nget_eigenvalues_of_current_state\nGet the eigenvalues of the current state of the system.\n\n\nget_parameters_of_dsl_models_in_composite_model\nReturns a dictionary with the parameter names (of the block definition)\n\n\ninitialize_and_run_sim\nInitialize and perform time domain simulation.\n\n\ninitialize_sim\nInitialize time domain simulation.\n\n\nis_dsl_lookup_arrays_and_matrices_name\ndsl has a special variable type for lookup tables. Such variables\n\n\nrun_sim\nPerform dynamic simulation.\n\n\nset_dsl_obj_array\nSet the array of a DSL object (‘Advanced 1’ tab).\n\n\nset_parameters_of_dsl_models_in_composite_model\nSet the parameters of the dsl models (i.e. of its block definition) in\n\n\n\n\n\ndyn_sim_interface.PFDynSimInterface.create_dyn_sim_event(name_incl_class, params={}, parent_folder=None, overwrite=True)\nCreates an event for dynamic simulations (RMS/EMT) and sets the parameters in ‘params’.\nArgs: name_incl_class (str): Event name including the class.\nparams (dict, optional): Paramter-values dictionary for created event object. Defaults to {}.\n\nparent_folder (PFGeneral | str, optional): Folder where event is created. If None, the events folder from the initial conditions calculation (ComInc) is used. Defaults to None.\n\noverwrite (bool, optional): Overwrite existing event with same name. Defaults to True.\n\n\n\ndyn_sim_interface.PFDynSimInterface.create_event(name_incl_class, params={}, parent_folder=None, overwrite=True)\nCreates an event and sets the parameters in ‘params’.\nArguments: name_incl_class: Event name including the class. params: Paramter-values dictionary. parent_folder: If None, the events folder from the initial conditions calculation (ComInc) is used. overwrite: Oerwrite existing event with same name.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_dsl_model_parameter_names(dsl_model)\nGet the parameter names of the block definition (BlkDef) of a dsl model.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_dsl_obj_array(dsl_obj, array_num=None, size_included_in_array=True)\nGet the array of DSL object (‘Advanced 1’ tab). The array_num specifies which array is returend (if None, all arays/colmns are returned). If size_included_in_array=True, the first row (where the size of the array is spedified) is included.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_eigenvalues_of_current_state(commod_parameters={})\nGet the eigenvalues of the current state of the system.\nUses the modal analysis command (ComMod) to calculate the eigenvalues. Eigenvectors and participation factors are omitted). The operating point of the current simulaiton time is used. Then uses result export (ComRes) to export the eigenvalues to csv, which is then read to a pandas DataFrame.\nArgs: commod_parameters (dict[str, str], optional): Additional parameter settings of modal analysis command (ComMod). Defaults to {}.\nReturns: pd.DataFrame: pandas DataFrame with columns “real in 1/s”, “imag in rad/s”\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_parameters_of_dsl_models_in_composite_model(composite_model, single_dict_for_all_dsl_models=False)\nReturns a dictionary with the parameter names (of the block definition) and values of all dsl models inside a composite model. dsl lookup varibales (e.g. ‘array_’, ’omatrix_’,.. ) are ignored.\nArguments: composite_model: ElmComp or its path single_dict_for_all_dsl_models: - If true, a single dictionary with the parameters of all dsl models is returned (no distinction is made between the dsl models). This assumes that a parameter that occurs in several dsl models has the same value. Example: {“a”: 1, “b”:0, “c”:2} - If false, the returned dictionary contains dictionaries for each dsl model. Example: { “controller_a”: {“a”: 1, “b”:0} “controller_b”: {“a”: 5, “c”:2} }\n\n\n\ndyn_sim_interface.PFDynSimInterface.initialize_and_run_sim()\nInitialize and perform time domain simulation.\n\n\n\ndyn_sim_interface.PFDynSimInterface.initialize_sim(param=None)\nInitialize time domain simulation. Parameters for ‘ComInc’ command object can be specified in ‘param’ dictionary.\n\n\n\ndyn_sim_interface.PFDynSimInterface.is_dsl_lookup_arrays_and_matrices_name(string)\ndsl has a special variable type for lookup tables. Such variables are defined using certain variable names starting with e.g. ‘array_’.\n\n\n\ndyn_sim_interface.PFDynSimInterface.run_sim(param=None)\nPerform dynamic simulation. Parameters for ‘ComSim’ command object can be specified in ‘param’ dictionary.\n\n\n\ndyn_sim_interface.PFDynSimInterface.set_dsl_obj_array(dsl_obj, rows, array_num=None, size_included_in_array=True)\nSet the array of a DSL object (‘Advanced 1’ tab). The array_num specifies which array is set (if None, all arrays/colums are set). If size_included_in_array=True, the first row (where the size of the array is specified) is included.\n\n\n\ndyn_sim_interface.PFDynSimInterface.set_parameters_of_dsl_models_in_composite_model(composite_model, models_params_dict, single_dict_for_all_dsl_models=False)\nSet the parameters of the dsl models (i.e. of its block definition) in a composite model. Arguments: composite_model: ElmComp or its path models_params_dict: dictionary with model parameters and values single_dict_for_all_dsl_models: - If true, models_params_dict is a single dictionary that is used to set the parameters of all dsl models. Example: {“a”: 1, “b”:0, “c”:2} -&gt; if a dsl model has an attribute (“a”,“b”, “c”), the value is set, otherwise it is ignored. - If false, models_params_dict contains dictionaries for each dsl model. Example: { “controller_a”: {“a”: 1, “b”:0} “controller_b”: {“a”: 5, “c”:2} }"
  },
  {
    "objectID": "docs/api/dyn_sim_interface.PFDynSimInterface.html#methods",
    "href": "docs/api/dyn_sim_interface.PFDynSimInterface.html#methods",
    "title": "dyn_sim_interface.PFDynSimInterface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_dyn_sim_event\nCreates an event for dynamic simulations (RMS/EMT) and sets the parameters in ‘params’.\n\n\ncreate_event\nCreates an event and sets the parameters in ‘params’.\n\n\nget_dsl_model_parameter_names\nGet the parameter names of the block definition (BlkDef)\n\n\nget_dsl_obj_array\nGet the array of DSL object (‘Advanced 1’ tab).\n\n\nget_eigenvalues_of_current_state\nGet the eigenvalues of the current state of the system.\n\n\nget_parameters_of_dsl_models_in_composite_model\nReturns a dictionary with the parameter names (of the block definition)\n\n\ninitialize_and_run_sim\nInitialize and perform time domain simulation.\n\n\ninitialize_sim\nInitialize time domain simulation.\n\n\nis_dsl_lookup_arrays_and_matrices_name\ndsl has a special variable type for lookup tables. Such variables\n\n\nrun_sim\nPerform dynamic simulation.\n\n\nset_dsl_obj_array\nSet the array of a DSL object (‘Advanced 1’ tab).\n\n\nset_parameters_of_dsl_models_in_composite_model\nSet the parameters of the dsl models (i.e. of its block definition) in\n\n\n\n\n\ndyn_sim_interface.PFDynSimInterface.create_dyn_sim_event(name_incl_class, params={}, parent_folder=None, overwrite=True)\nCreates an event for dynamic simulations (RMS/EMT) and sets the parameters in ‘params’.\nArgs: name_incl_class (str): Event name including the class.\nparams (dict, optional): Paramter-values dictionary for created event object. Defaults to {}.\n\nparent_folder (PFGeneral | str, optional): Folder where event is created. If None, the events folder from the initial conditions calculation (ComInc) is used. Defaults to None.\n\noverwrite (bool, optional): Overwrite existing event with same name. Defaults to True.\n\n\n\ndyn_sim_interface.PFDynSimInterface.create_event(name_incl_class, params={}, parent_folder=None, overwrite=True)\nCreates an event and sets the parameters in ‘params’.\nArguments: name_incl_class: Event name including the class. params: Paramter-values dictionary. parent_folder: If None, the events folder from the initial conditions calculation (ComInc) is used. overwrite: Oerwrite existing event with same name.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_dsl_model_parameter_names(dsl_model)\nGet the parameter names of the block definition (BlkDef) of a dsl model.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_dsl_obj_array(dsl_obj, array_num=None, size_included_in_array=True)\nGet the array of DSL object (‘Advanced 1’ tab). The array_num specifies which array is returend (if None, all arays/colmns are returned). If size_included_in_array=True, the first row (where the size of the array is spedified) is included.\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_eigenvalues_of_current_state(commod_parameters={})\nGet the eigenvalues of the current state of the system.\nUses the modal analysis command (ComMod) to calculate the eigenvalues. Eigenvectors and participation factors are omitted). The operating point of the current simulaiton time is used. Then uses result export (ComRes) to export the eigenvalues to csv, which is then read to a pandas DataFrame.\nArgs: commod_parameters (dict[str, str], optional): Additional parameter settings of modal analysis command (ComMod). Defaults to {}.\nReturns: pd.DataFrame: pandas DataFrame with columns “real in 1/s”, “imag in rad/s”\n\n\n\ndyn_sim_interface.PFDynSimInterface.get_parameters_of_dsl_models_in_composite_model(composite_model, single_dict_for_all_dsl_models=False)\nReturns a dictionary with the parameter names (of the block definition) and values of all dsl models inside a composite model. dsl lookup varibales (e.g. ‘array_’, ’omatrix_’,.. ) are ignored.\nArguments: composite_model: ElmComp or its path single_dict_for_all_dsl_models: - If true, a single dictionary with the parameters of all dsl models is returned (no distinction is made between the dsl models). This assumes that a parameter that occurs in several dsl models has the same value. Example: {“a”: 1, “b”:0, “c”:2} - If false, the returned dictionary contains dictionaries for each dsl model. Example: { “controller_a”: {“a”: 1, “b”:0} “controller_b”: {“a”: 5, “c”:2} }\n\n\n\ndyn_sim_interface.PFDynSimInterface.initialize_and_run_sim()\nInitialize and perform time domain simulation.\n\n\n\ndyn_sim_interface.PFDynSimInterface.initialize_sim(param=None)\nInitialize time domain simulation. Parameters for ‘ComInc’ command object can be specified in ‘param’ dictionary.\n\n\n\ndyn_sim_interface.PFDynSimInterface.is_dsl_lookup_arrays_and_matrices_name(string)\ndsl has a special variable type for lookup tables. Such variables are defined using certain variable names starting with e.g. ‘array_’.\n\n\n\ndyn_sim_interface.PFDynSimInterface.run_sim(param=None)\nPerform dynamic simulation. Parameters for ‘ComSim’ command object can be specified in ‘param’ dictionary.\n\n\n\ndyn_sim_interface.PFDynSimInterface.set_dsl_obj_array(dsl_obj, rows, array_num=None, size_included_in_array=True)\nSet the array of a DSL object (‘Advanced 1’ tab). The array_num specifies which array is set (if None, all arrays/colums are set). If size_included_in_array=True, the first row (where the size of the array is specified) is included.\n\n\n\ndyn_sim_interface.PFDynSimInterface.set_parameters_of_dsl_models_in_composite_model(composite_model, models_params_dict, single_dict_for_all_dsl_models=False)\nSet the parameters of the dsl models (i.e. of its block definition) in a composite model. Arguments: composite_model: ElmComp or its path models_params_dict: dictionary with model parameters and values single_dict_for_all_dsl_models: - If true, models_params_dict is a single dictionary that is used to set the parameters of all dsl models. Example: {“a”: 1, “b”:0, “c”:2} -&gt; if a dsl model has an attribute (“a”,“b”, “c”), the value is set, otherwise it is ignored. - If false, models_params_dict contains dictionaries for each dsl model. Example: { “controller_a”: {“a”: 1, “b”:0} “controller_b”: {“a”: 5, “c”:2} }"
  },
  {
    "objectID": "docs/api/plot_interface.PFPlotInterface.html",
    "href": "docs/api/plot_interface.PFPlotInterface.html",
    "title": "plot_interface.PFPlotInterface",
    "section": "",
    "text": "plot_interface.PFPlotInterface(self, app)\n\n\n\n\n\nName\nDescription\n\n\n\n\nactive_graphics_page\nCurrently active graphics page.\n\n\nactive_plot\nCurrently active plot.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nautoscale\nAutoscale all axis.\n\n\nclear_curves\nClear all curves from active plot.\n\n\nclear_curves_by_index_from_active_plot\nClear curves with certain index from plot (i.e. its data series).\n\n\nclear_curves_from_all_plots\nClear curves from all plots of the active study case.\n\n\nclear_curves_from_curve_table_attributes_dict\nClear curves from a dictionary with the curve table attributes (keys)\n\n\nclear_graphics_board\nClear the graphics board from specific objects or from all objects.\n\n\nclear_plot_pages\nDeletes all graphics (plot) pages from the graphics board of\n\n\ncopy_graphics_board_content\nCopy the graphics board content of a study case to another study cases.\n\n\ncopy_graphics_board_content_to_all_study_cases\nCopy the content of the graphics board to all study cases.\n\n\ncreate_dummy_network\nCreates a network with only one terminal.\n\n\nexport_active_page\nExport active page (e.g. to pdf) using the ‘ComWr’ object.\n\n\nget_curve_table_attributes\nGet dictionary with all curve table attributes (keys) and\n\n\nget_curve_table_attributes_referring_to_data_source\nGet the curve table attributes referring to the data source\n\n\nget_curve_table_attributes_referring_to_visualization\nGet the curve table attributes of a plot (i.e. its data series)\n\n\nget_data_series_of_active_plot\nGet dataseries object of the currently active plot.\n\n\nget_data_series_of_plot\nReturns the data series object of a plot. If plot is None, the active plot is used.\n\n\nget_or_create_graphics_board\nGet the graphics board of the currently active study case or create\n\n\nget_x_axis_of_active_plot\nGet the x-axis of the currently active plot.\n\n\nget_y_axis_of_active_plot\nGet the y-axis of the currently active plot.\n\n\nplot\nPlots the variables of ‘obj’ to the currently active plot.\n\n\nplot_from_comtrade\nPlot a varibale from a COMTRADE formated file.\n\n\nplot_from_csv\nPlot results from csv file using pyplot.\n\n\nplot_from_csv_using_elm_file\nUse an ElmFile object to plot data from csv file.\n\n\nplot_monitored_variables\nPlot varibales. Variables must have been added to the monitored\n\n\nset_active_graphics_page\nSets the active graphics page.\n\n\nset_active_plot\nSet the currently active plot.\n\n\nset_all_fonts_of_active_plot\nSets the fonts of all text elements (axis labels,legend,title).\n\n\nset_curve_attributes\nSet curve attributes in dataseries object of a plot.\n\n\nset_curve_table_attributes\nSet the curve table attributes of a plot (i.e. its data series).\n\n\nset_x_axis_attributes\nSet y-axis attributes.\n\n\nset_y_axis_attributes\nSet y-axis attributes.\n\n\n\n\n\nplot_interface.PFPlotInterface.autoscale()\nAutoscale all axis.\nToDo: Check if this really works as excpeted.\n\n\n\nplot_interface.PFPlotInterface.clear_curves()\nClear all curves from active plot.\n\n\n\nplot_interface.PFPlotInterface.clear_curves_by_index_from_active_plot(index)\nClear curves with certain index from plot (i.e. its data series). IMPORTANT: Zero based indexing is used i.e. the first curve has index 0. The native PF API has no such functionality and can only delete all curves. The method works as follows: - gets the curve table attributes in a dictionary - clears all curves from plot - clear certain curves from the dictionary - set the curve table attributes according to the dictionary\nArguments: - index (int | slice): for a detailled description please have a look at clear_curves_from_curve_table_attributes_dict\n\n\n\nplot_interface.PFPlotInterface.clear_curves_from_all_plots()\nClear curves from all plots of the active study case.\n\n\n\nplot_interface.PFPlotInterface.clear_curves_from_curve_table_attributes_dict(attributes, index)\nClear curves from a dictionary with the curve table attributes (keys) and the entries for each curve (values).\nIMPORTANT: Zero based indexing is used i.e. the first curve has index 0. Note that this does not clear the curves from the data series in the PF plot, but only from the dictionary. If you want to clear the curves from a plot, use clear_curves_by_index_from_active_plot\nArguments: - attributes (dict): dictionary with attribute names (keys) and entries for each curve (values) - index (int | slice): can be an integer or slice - integer: index of one curve to be deleted - slice: several curves are deleted. Examples: - slices have the general form “slice(start, end, step)” (see for example https://www.programiz.com/python-programming/methods/built-in/slice) - “slice(2,4)”: clear curves with index 2,3 (step=1 is default) - “slice(-1,1,-1): start at the end and delete all curves larger than index 1\n\n\n\nplot_interface.PFPlotInterface.clear_graphics_board(obj='*')\nClear the graphics board from specific objects or from all objects. Objects of class SetDeskpage are closed, objects of class GrpPage are removed, other objects are deleted.\nArgs: obj (str, optional): Object name (can include class and placeholders). Defaults to “*“.\n\n\n\nplot_interface.PFPlotInterface.clear_plot_pages()\nDeletes all graphics (plot) pages from the graphics board of the active study case.\n\n\n\nplot_interface.PFPlotInterface.copy_graphics_board_content(source_study_case, target_study_cases, obj_to_copy='*', clear_target_graphics_board=False)\nCopy the graphics board content of a study case to another study cases.\nArgs: source_study_case (str | IntCase): Source case (path or object)\ntarget_study_cases (str | IntCase | list[str] | list[IntCase]): Target case(s) (path(s) or object(s))\n\nobj_to_copy (str, optional): name of objects to be copied from graphics board.(e.g. \"*.GrpPage\" to copy only the plot pages). Defaults to \"*\".\n\nclear_target_graphics_board (bool, optional): If true, the graphics boards of the target cases are cleared before pasting the content. Defaults to False.\n\n\n\nplot_interface.PFPlotInterface.copy_graphics_board_content_to_all_study_cases(source_study_case, target_parent_folder=None, include_subfolders=True, obj_to_copy='*', clear_target_graphics_board=False)\nCopy the content of the graphics board to all study cases.\nArgs: source_study_case (str | IntCase): Source case (path or object)\ntarget_parent_folder (str | PFGeneral, optional): Parent folder of target cases. By default, the study case folder of the project is used. Any folder inside the study case folder of the project can be specified.\n\ninclude_subfolders (bool, optional): Applies to search for target study cases. Defaults to True.\n\nobj_to_copy (str, optional): name of objects to be copied from graphics board (e.g. \"*.GrpPage\" to copy only the plot pages). . Defaults to \"*\".\n\nclear_target_graphics_board (bool, optional): If true, the graphics boards of the target cases are cleared before pasting the content. Defaults to False.\n\n\n\nplot_interface.PFPlotInterface.create_dummy_network(name='dummy_network')\nCreates a network with only one terminal. Such a network is used for example to read in ElmFile objects.\n\n\n\nplot_interface.PFPlotInterface.export_active_page(format='pdf', path=getcwd())\nExport active page (e.g. to pdf) using the ‘ComWr’ object.\nArgs: format (str, optional): Export format. Defaults to ‘pdf’. path (str, optional): Export path. Defaults to current working directory (getcwd()).\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes(plot=None, adjust_result_file=True)\nGet dictionary with all curve table attributes (keys) and list with the attributes values for each curve (values) of a plot (i.e. its data series).\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used.\nadjust_result_file (bool, optional): please see get_curve_table_attributes_referring_to_data_source\nfor a detailed description . Defaults to True.\nReturns: dict[str, list]: curve table attributes\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes_referring_to_data_source(plot=None, adjust_result_file=True)\nGet the curve table attributes referring to the data source of the curves from a plot (i.e. its data series).\nThese attributes are: “curveTableResultFile”, “curveTableElement”, “curveTableVariable”\nUse this method if the data sources of the curves are of interest. If further attributes on visualisation are of interest, see also the methods: - get_curve_table_attributes - get_curve_table_attributes_referring_to_visualization\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used. Defaults to None.\nadjust_result_file (bool, optional): Defaults to True.\n  - If False, the list in \"curveTableResultFile\" is used as is\n  - If True, the list is adjusted depending on the plot settings\n    \"useIndividualResults\". If \"useIndividualResults\" is True,\n    the result files from the list \"curveTableResultFile\" are used\n    by default. If an element of this list is empty, the \n    \"userSelectedResultFile\" is used. Note that there is a bug in\n    PF so that \"autoSelectedResultFile\" is always empty as described \n    below.\nReturns: dict: - keys: attribute names - values: lists with the values for each curve\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes_referring_to_visualization(plot=None)\nGet the curve table attributes of a plot (i.e. its data series) that refer to the visualisation.\nThe return value is a dictionary with - keys: attribute names - values: lists with the values for each curve\nUse this method if the data sources of the curves are of interest. If further attributes on the data sources are of interest, see also the methods: - get_curve_table_attributes - get_curve_table_attributes_referring_to_data_source\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used. Defaults to None.\nReturns: dict[str, object]: dict with attributes and their values.\n\n\n\nplot_interface.PFPlotInterface.get_data_series_of_active_plot()\nGet dataseries object of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.get_data_series_of_plot(plot=None)\nReturns the data series object of a plot. If plot is None, the active plot is used.\n\n\n\nplot_interface.PFPlotInterface.get_or_create_graphics_board()\nGet the graphics board of the currently active study case or create a new graphics board if it does not exist within the study case yet.\n\n\n\nplot_interface.PFPlotInterface.get_x_axis_of_active_plot()\nGet the x-axis of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.get_y_axis_of_active_plot()\nGet the y-axis of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.plot(obj, variables, graphics_page=None, plot=None, **kwargs)\nPlots the variables of ‘obj’ to the currently active plot.\nAlso adds the variables to the results (ElmRes) object. The active plot can be set with the optional arguments.\nArgs:\nobj (PFGeneral): Object (e.g. of class ‘Elm…’) of which variables are plotted.\nvariables (str | list[str]): string or list of variable names\ngraphics_page (str | GrpPage | SetVipage, optional): Defaults to None.\nplot (str | VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None.\nkwargs:\nresults_obj: result object used (object or path) linestyle: int linewidth: double color: int label: str\n\n\n\nplot_interface.PFPlotInterface.plot_from_comtrade(file_path, variables, graphics_page=None, plot=None, parent_folder_comtrade=None, **kwargs)\nPlot a varibale from a COMTRADE formated file.\nCreates the comtrade object (IntComtrade) and plots. For further info on the arguments see method ‘plot_monitored_variables’.\nIf you want to plot from a comtrade object (IntComtrade) that already exists in the PF database, use the method ‘plot_monitored_variables’ as shown in the code below.\nArgs: file_path (str): of comtrade file\nvariables (str | list[str]): The entry in the second column of a signal in .cfg\n\ngraphics_page (str | GrpPage | SetVipage, optional): _description_. Defaults to None.\n\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): _description_. Defaults to None.\n\nparent_folder_comtrade (str | PFGeneral, optional): FolderContainer in PF database for comtrade objects (str or PF object). Defaults to None (\"Comtrade.IntFolder\" in active study case is used).\n\n\n\nplot_interface.PFPlotInterface.plot_from_csv(csv_path, variables, offset=0, plot_interface=None)\nPlot results from csv file using pyplot.\nArgs: csv_path (str): path of csv file variables (str | list[str]): variables to be plotted offset (float, optional): time offset. Defaults to 0. plot_interface (object, optional): description. Defaults to None.\nReturns: VisPlot | PltLinebarplot | PltVectorplot: Returns the plot.\nExample: plot_from_csv(“results.csv”, [“Network ModelDataVoltage Source:u0”, “Network ModelDataVoltage Source:Psum:bus1”])\n\n\n\nplot_interface.PFPlotInterface.plot_from_csv_using_elm_file(file_path, variable, **kwargs)\nUse an ElmFile object to plot data from csv file.\nIt is generally preferrable and more stable to use the COMTRADE format to plot external data.\nThe ElmFile objects are stored in a dummy network because the simulation needs to be run to read the data from the csv file and is not just printed to the plot automatically.\nArgs: file_path (str): path to csv file variable (str): varaible name in csv file header\n\n\n\nplot_interface.PFPlotInterface.plot_monitored_variables(obj, variables, graphics_page=None, plot=None, **kwargs)\nPlot varibales. Variables must have been added to the monitored variables before (e.g. using ‘add_results_variable’).\nArgs: obj (PFGeneral): Object (e.g. of class ‘Elm…’) of which variables are plotted.\nvariables (str | list[str]): Variable(s) to be plotted.\n\ngraphics_page (str | GrpPage | SetVipage, optional): Graphics page. Defaults to None.\n\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None.\n\nkwargs:\n  results_obj: result object used (object or path)\n  linestyle: int\n  linewidth: double\n  color: int\n  label: str\n\n\n\nplot_interface.PFPlotInterface.set_active_graphics_page(page)\nSets the active graphics page.\nArgs: page (str | GrpPage | SetVipage): graphics page object or name\n\n\n\nplot_interface.PFPlotInterface.set_active_plot(name_or_obj, graphics_page=None)\nSet the currently active plot.\nAdjusts the active graphics page accordingly if ‘name_or_object’ is a PF plot object (the graphics page cannot be infered from a string path) or if the optional argument graphics_page is given.\nArgs: name_or_obj (str): name of plot (string) or plot object graphics_page (str | GrpPage | SetVipage, optional): Graphics page object or string. Defaults to None.\n\n\n\nplot_interface.PFPlotInterface.set_all_fonts_of_active_plot(fontsize=10, fontname='Arial', fontstyle=0)\nSets the fonts of all text elements (axis labels,legend,title).\nNote that the fonts are not attributes of the PF objects (x-axis, title object,..), but can only be set using the method ‘SetFont’.\nArgs: fontsize (int, optional): Defaults to 10. fontname (str, optional): Defaults to “Arial”. fontstyle (int, optional): Defaults to 0.\n\n\n\nplot_interface.PFPlotInterface.set_curve_attributes(data_series=None, curve_num=-1, **kwargs)\nSet curve attributes in dataseries object of a plot.\nArgs: data_series (PltDataseries, optional): data series of plot. Defaults to None (dataseries of active plot is used).\ncurve_num (int, optional): Curve number. Defaults to -1 (last curve).\n\nkwargs:\n  results_obj: result object used (object or path)\n  linestyle: int\n  linewidth: double\n  color: int\n  label: str\n\n\n\nplot_interface.PFPlotInterface.set_curve_table_attributes(attributes, plot=None)\nSet the curve table attributes of a plot (i.e. its data series).\nArgs: attributes (dict[str, list]): a dictionary with - keys: argument names, e.g. “curveTableLabel” - values: list with the values for each curve\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None (active plot is used).\n\n\n\nplot_interface.PFPlotInterface.set_x_axis_attributes(**kwargs)\nSet y-axis attributes.\nArgs: kwargs: key-value-pairs of axis-related PF attributes and their value.\n\n\n\nplot_interface.PFPlotInterface.set_y_axis_attributes(**kwargs)\nSet y-axis attributes.\nArgs: kwargs: key-value-pairs of axis-related PF attributes and their value."
  },
  {
    "objectID": "docs/api/plot_interface.PFPlotInterface.html#attributes",
    "href": "docs/api/plot_interface.PFPlotInterface.html#attributes",
    "title": "plot_interface.PFPlotInterface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nactive_graphics_page\nCurrently active graphics page.\n\n\nactive_plot\nCurrently active plot."
  },
  {
    "objectID": "docs/api/plot_interface.PFPlotInterface.html#methods",
    "href": "docs/api/plot_interface.PFPlotInterface.html#methods",
    "title": "plot_interface.PFPlotInterface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nautoscale\nAutoscale all axis.\n\n\nclear_curves\nClear all curves from active plot.\n\n\nclear_curves_by_index_from_active_plot\nClear curves with certain index from plot (i.e. its data series).\n\n\nclear_curves_from_all_plots\nClear curves from all plots of the active study case.\n\n\nclear_curves_from_curve_table_attributes_dict\nClear curves from a dictionary with the curve table attributes (keys)\n\n\nclear_graphics_board\nClear the graphics board from specific objects or from all objects.\n\n\nclear_plot_pages\nDeletes all graphics (plot) pages from the graphics board of\n\n\ncopy_graphics_board_content\nCopy the graphics board content of a study case to another study cases.\n\n\ncopy_graphics_board_content_to_all_study_cases\nCopy the content of the graphics board to all study cases.\n\n\ncreate_dummy_network\nCreates a network with only one terminal.\n\n\nexport_active_page\nExport active page (e.g. to pdf) using the ‘ComWr’ object.\n\n\nget_curve_table_attributes\nGet dictionary with all curve table attributes (keys) and\n\n\nget_curve_table_attributes_referring_to_data_source\nGet the curve table attributes referring to the data source\n\n\nget_curve_table_attributes_referring_to_visualization\nGet the curve table attributes of a plot (i.e. its data series)\n\n\nget_data_series_of_active_plot\nGet dataseries object of the currently active plot.\n\n\nget_data_series_of_plot\nReturns the data series object of a plot. If plot is None, the active plot is used.\n\n\nget_or_create_graphics_board\nGet the graphics board of the currently active study case or create\n\n\nget_x_axis_of_active_plot\nGet the x-axis of the currently active plot.\n\n\nget_y_axis_of_active_plot\nGet the y-axis of the currently active plot.\n\n\nplot\nPlots the variables of ‘obj’ to the currently active plot.\n\n\nplot_from_comtrade\nPlot a varibale from a COMTRADE formated file.\n\n\nplot_from_csv\nPlot results from csv file using pyplot.\n\n\nplot_from_csv_using_elm_file\nUse an ElmFile object to plot data from csv file.\n\n\nplot_monitored_variables\nPlot varibales. Variables must have been added to the monitored\n\n\nset_active_graphics_page\nSets the active graphics page.\n\n\nset_active_plot\nSet the currently active plot.\n\n\nset_all_fonts_of_active_plot\nSets the fonts of all text elements (axis labels,legend,title).\n\n\nset_curve_attributes\nSet curve attributes in dataseries object of a plot.\n\n\nset_curve_table_attributes\nSet the curve table attributes of a plot (i.e. its data series).\n\n\nset_x_axis_attributes\nSet y-axis attributes.\n\n\nset_y_axis_attributes\nSet y-axis attributes.\n\n\n\n\n\nplot_interface.PFPlotInterface.autoscale()\nAutoscale all axis.\nToDo: Check if this really works as excpeted.\n\n\n\nplot_interface.PFPlotInterface.clear_curves()\nClear all curves from active plot.\n\n\n\nplot_interface.PFPlotInterface.clear_curves_by_index_from_active_plot(index)\nClear curves with certain index from plot (i.e. its data series). IMPORTANT: Zero based indexing is used i.e. the first curve has index 0. The native PF API has no such functionality and can only delete all curves. The method works as follows: - gets the curve table attributes in a dictionary - clears all curves from plot - clear certain curves from the dictionary - set the curve table attributes according to the dictionary\nArguments: - index (int | slice): for a detailled description please have a look at clear_curves_from_curve_table_attributes_dict\n\n\n\nplot_interface.PFPlotInterface.clear_curves_from_all_plots()\nClear curves from all plots of the active study case.\n\n\n\nplot_interface.PFPlotInterface.clear_curves_from_curve_table_attributes_dict(attributes, index)\nClear curves from a dictionary with the curve table attributes (keys) and the entries for each curve (values).\nIMPORTANT: Zero based indexing is used i.e. the first curve has index 0. Note that this does not clear the curves from the data series in the PF plot, but only from the dictionary. If you want to clear the curves from a plot, use clear_curves_by_index_from_active_plot\nArguments: - attributes (dict): dictionary with attribute names (keys) and entries for each curve (values) - index (int | slice): can be an integer or slice - integer: index of one curve to be deleted - slice: several curves are deleted. Examples: - slices have the general form “slice(start, end, step)” (see for example https://www.programiz.com/python-programming/methods/built-in/slice) - “slice(2,4)”: clear curves with index 2,3 (step=1 is default) - “slice(-1,1,-1): start at the end and delete all curves larger than index 1\n\n\n\nplot_interface.PFPlotInterface.clear_graphics_board(obj='*')\nClear the graphics board from specific objects or from all objects. Objects of class SetDeskpage are closed, objects of class GrpPage are removed, other objects are deleted.\nArgs: obj (str, optional): Object name (can include class and placeholders). Defaults to “*“.\n\n\n\nplot_interface.PFPlotInterface.clear_plot_pages()\nDeletes all graphics (plot) pages from the graphics board of the active study case.\n\n\n\nplot_interface.PFPlotInterface.copy_graphics_board_content(source_study_case, target_study_cases, obj_to_copy='*', clear_target_graphics_board=False)\nCopy the graphics board content of a study case to another study cases.\nArgs: source_study_case (str | IntCase): Source case (path or object)\ntarget_study_cases (str | IntCase | list[str] | list[IntCase]): Target case(s) (path(s) or object(s))\n\nobj_to_copy (str, optional): name of objects to be copied from graphics board.(e.g. \"*.GrpPage\" to copy only the plot pages). Defaults to \"*\".\n\nclear_target_graphics_board (bool, optional): If true, the graphics boards of the target cases are cleared before pasting the content. Defaults to False.\n\n\n\nplot_interface.PFPlotInterface.copy_graphics_board_content_to_all_study_cases(source_study_case, target_parent_folder=None, include_subfolders=True, obj_to_copy='*', clear_target_graphics_board=False)\nCopy the content of the graphics board to all study cases.\nArgs: source_study_case (str | IntCase): Source case (path or object)\ntarget_parent_folder (str | PFGeneral, optional): Parent folder of target cases. By default, the study case folder of the project is used. Any folder inside the study case folder of the project can be specified.\n\ninclude_subfolders (bool, optional): Applies to search for target study cases. Defaults to True.\n\nobj_to_copy (str, optional): name of objects to be copied from graphics board (e.g. \"*.GrpPage\" to copy only the plot pages). . Defaults to \"*\".\n\nclear_target_graphics_board (bool, optional): If true, the graphics boards of the target cases are cleared before pasting the content. Defaults to False.\n\n\n\nplot_interface.PFPlotInterface.create_dummy_network(name='dummy_network')\nCreates a network with only one terminal. Such a network is used for example to read in ElmFile objects.\n\n\n\nplot_interface.PFPlotInterface.export_active_page(format='pdf', path=getcwd())\nExport active page (e.g. to pdf) using the ‘ComWr’ object.\nArgs: format (str, optional): Export format. Defaults to ‘pdf’. path (str, optional): Export path. Defaults to current working directory (getcwd()).\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes(plot=None, adjust_result_file=True)\nGet dictionary with all curve table attributes (keys) and list with the attributes values for each curve (values) of a plot (i.e. its data series).\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used.\nadjust_result_file (bool, optional): please see get_curve_table_attributes_referring_to_data_source\nfor a detailed description . Defaults to True.\nReturns: dict[str, list]: curve table attributes\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes_referring_to_data_source(plot=None, adjust_result_file=True)\nGet the curve table attributes referring to the data source of the curves from a plot (i.e. its data series).\nThese attributes are: “curveTableResultFile”, “curveTableElement”, “curveTableVariable”\nUse this method if the data sources of the curves are of interest. If further attributes on visualisation are of interest, see also the methods: - get_curve_table_attributes - get_curve_table_attributes_referring_to_visualization\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used. Defaults to None.\nadjust_result_file (bool, optional): Defaults to True.\n  - If False, the list in \"curveTableResultFile\" is used as is\n  - If True, the list is adjusted depending on the plot settings\n    \"useIndividualResults\". If \"useIndividualResults\" is True,\n    the result files from the list \"curveTableResultFile\" are used\n    by default. If an element of this list is empty, the \n    \"userSelectedResultFile\" is used. Note that there is a bug in\n    PF so that \"autoSelectedResultFile\" is always empty as described \n    below.\nReturns: dict: - keys: attribute names - values: lists with the values for each curve\n\n\n\nplot_interface.PFPlotInterface.get_curve_table_attributes_referring_to_visualization(plot=None)\nGet the curve table attributes of a plot (i.e. its data series) that refer to the visualisation.\nThe return value is a dictionary with - keys: attribute names - values: lists with the values for each curve\nUse this method if the data sources of the curves are of interest. If further attributes on the data sources are of interest, see also the methods: - get_curve_table_attributes - get_curve_table_attributes_referring_to_data_source\nArgs: plot (VisPlot | PltLinebarplot | PltVectorplot, optional): path or PF object. If None, the active plot is used. Defaults to None.\nReturns: dict[str, object]: dict with attributes and their values.\n\n\n\nplot_interface.PFPlotInterface.get_data_series_of_active_plot()\nGet dataseries object of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.get_data_series_of_plot(plot=None)\nReturns the data series object of a plot. If plot is None, the active plot is used.\n\n\n\nplot_interface.PFPlotInterface.get_or_create_graphics_board()\nGet the graphics board of the currently active study case or create a new graphics board if it does not exist within the study case yet.\n\n\n\nplot_interface.PFPlotInterface.get_x_axis_of_active_plot()\nGet the x-axis of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.get_y_axis_of_active_plot()\nGet the y-axis of the currently active plot.\n\n\n\nplot_interface.PFPlotInterface.plot(obj, variables, graphics_page=None, plot=None, **kwargs)\nPlots the variables of ‘obj’ to the currently active plot.\nAlso adds the variables to the results (ElmRes) object. The active plot can be set with the optional arguments.\nArgs:\nobj (PFGeneral): Object (e.g. of class ‘Elm…’) of which variables are plotted.\nvariables (str | list[str]): string or list of variable names\ngraphics_page (str | GrpPage | SetVipage, optional): Defaults to None.\nplot (str | VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None.\nkwargs:\nresults_obj: result object used (object or path) linestyle: int linewidth: double color: int label: str\n\n\n\nplot_interface.PFPlotInterface.plot_from_comtrade(file_path, variables, graphics_page=None, plot=None, parent_folder_comtrade=None, **kwargs)\nPlot a varibale from a COMTRADE formated file.\nCreates the comtrade object (IntComtrade) and plots. For further info on the arguments see method ‘plot_monitored_variables’.\nIf you want to plot from a comtrade object (IntComtrade) that already exists in the PF database, use the method ‘plot_monitored_variables’ as shown in the code below.\nArgs: file_path (str): of comtrade file\nvariables (str | list[str]): The entry in the second column of a signal in .cfg\n\ngraphics_page (str | GrpPage | SetVipage, optional): _description_. Defaults to None.\n\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): _description_. Defaults to None.\n\nparent_folder_comtrade (str | PFGeneral, optional): FolderContainer in PF database for comtrade objects (str or PF object). Defaults to None (\"Comtrade.IntFolder\" in active study case is used).\n\n\n\nplot_interface.PFPlotInterface.plot_from_csv(csv_path, variables, offset=0, plot_interface=None)\nPlot results from csv file using pyplot.\nArgs: csv_path (str): path of csv file variables (str | list[str]): variables to be plotted offset (float, optional): time offset. Defaults to 0. plot_interface (object, optional): description. Defaults to None.\nReturns: VisPlot | PltLinebarplot | PltVectorplot: Returns the plot.\nExample: plot_from_csv(“results.csv”, [“Network ModelDataVoltage Source:u0”, “Network ModelDataVoltage Source:Psum:bus1”])\n\n\n\nplot_interface.PFPlotInterface.plot_from_csv_using_elm_file(file_path, variable, **kwargs)\nUse an ElmFile object to plot data from csv file.\nIt is generally preferrable and more stable to use the COMTRADE format to plot external data.\nThe ElmFile objects are stored in a dummy network because the simulation needs to be run to read the data from the csv file and is not just printed to the plot automatically.\nArgs: file_path (str): path to csv file variable (str): varaible name in csv file header\n\n\n\nplot_interface.PFPlotInterface.plot_monitored_variables(obj, variables, graphics_page=None, plot=None, **kwargs)\nPlot varibales. Variables must have been added to the monitored variables before (e.g. using ‘add_results_variable’).\nArgs: obj (PFGeneral): Object (e.g. of class ‘Elm…’) of which variables are plotted.\nvariables (str | list[str]): Variable(s) to be plotted.\n\ngraphics_page (str | GrpPage | SetVipage, optional): Graphics page. Defaults to None.\n\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None.\n\nkwargs:\n  results_obj: result object used (object or path)\n  linestyle: int\n  linewidth: double\n  color: int\n  label: str\n\n\n\nplot_interface.PFPlotInterface.set_active_graphics_page(page)\nSets the active graphics page.\nArgs: page (str | GrpPage | SetVipage): graphics page object or name\n\n\n\nplot_interface.PFPlotInterface.set_active_plot(name_or_obj, graphics_page=None)\nSet the currently active plot.\nAdjusts the active graphics page accordingly if ‘name_or_object’ is a PF plot object (the graphics page cannot be infered from a string path) or if the optional argument graphics_page is given.\nArgs: name_or_obj (str): name of plot (string) or plot object graphics_page (str | GrpPage | SetVipage, optional): Graphics page object or string. Defaults to None.\n\n\n\nplot_interface.PFPlotInterface.set_all_fonts_of_active_plot(fontsize=10, fontname='Arial', fontstyle=0)\nSets the fonts of all text elements (axis labels,legend,title).\nNote that the fonts are not attributes of the PF objects (x-axis, title object,..), but can only be set using the method ‘SetFont’.\nArgs: fontsize (int, optional): Defaults to 10. fontname (str, optional): Defaults to “Arial”. fontstyle (int, optional): Defaults to 0.\n\n\n\nplot_interface.PFPlotInterface.set_curve_attributes(data_series=None, curve_num=-1, **kwargs)\nSet curve attributes in dataseries object of a plot.\nArgs: data_series (PltDataseries, optional): data series of plot. Defaults to None (dataseries of active plot is used).\ncurve_num (int, optional): Curve number. Defaults to -1 (last curve).\n\nkwargs:\n  results_obj: result object used (object or path)\n  linestyle: int\n  linewidth: double\n  color: int\n  label: str\n\n\n\nplot_interface.PFPlotInterface.set_curve_table_attributes(attributes, plot=None)\nSet the curve table attributes of a plot (i.e. its data series).\nArgs: attributes (dict[str, list]): a dictionary with - keys: argument names, e.g. “curveTableLabel” - values: list with the values for each curve\nplot (VisPlot | PltLinebarplot | PltVectorplot, optional): Plot object. Defaults to None (active plot is used).\n\n\n\nplot_interface.PFPlotInterface.set_x_axis_attributes(**kwargs)\nSet y-axis attributes.\nArgs: kwargs: key-value-pairs of axis-related PF attributes and their value.\n\n\n\nplot_interface.PFPlotInterface.set_y_axis_attributes(**kwargs)\nSet y-axis attributes.\nArgs: kwargs: key-value-pairs of axis-related PF attributes and their value."
  },
  {
    "objectID": "docs/api/active_project_interface.html",
    "href": "docs/api/active_project_interface.html",
    "title": "active_project_interface",
    "section": "",
    "text": "active_project_interface\n\n\n\n\n\nName\nDescription\n\n\n\n\nPFActiveProject\nInterface to the currently active project.\n\n\nPFBaseInterface\nPlease use the class PFActiveProject instead.\n\n\n\n\n\nactive_project_interface.PFActiveProject(self, pf_app)\nInterface to the currently active project.\n\n\n\n\n\nName\nDescription\n\n\n\n\nactivate_study_case\nActivate study case under path.\n\n\nadd_results_variable\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\n\n\nadd_variable_selection_obj_to_results_obj\nAdd a varible selection object (IntMon) to a result object (ElmRes).\n\n\nclear_elmres\nClear all results variables from results object (ElmRes).\n\n\nclear_elmres_from_objects_with_status_deleted\nDeletes all objects from a results object (ElmRes) that have the\n\n\ncreate_comtrade_obj\nAdd an IntComtrade that refers to file_path (*.cfg).\n\n\ncreate_project_version\nCreate a version of current state of the project.\n\n\ncreate_variation\nCreate variation (including one expansion stage).\n\n\nget_active_networks\nGet active networks/grids.\n\n\nget_active_study_case\nGet the currently active study case. Control whether error should be raised if no case is active.\n\n\nget_active_user_folder\nGet folder of active user.\n\n\nget_calc_relevant_obj\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\n\n\nget_events_folder_from_initial_conditions_calc\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\n\n\nget_first_level_folder\nGet folder on first level of PF database.\n\n\nget_from_study_case\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\n\n\nget_parameter_value_string\nGet string with parameters and their values.\n\n\nget_project_version\nGet (previous) version of project.\n\n\nget_results_obj_from_initial_conditions_calc\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\n\n\nimport_project\nImport a project (.pfd file)\n\n\ninsert_row_with_number_of_columns_in_csv_file\nGets the number of columns of the first row in a csv file and\n\n\nreplace_headers_of_csv_file_with_number_of_colums\nReplaces the first row (headers) of a csv file with its number of\n\n\nrollback_project_to_previous_version\nRollback to previous project version (IntVersion in versions folder).\n\n\n\n\n\nactive_project_interface.PFActiveProject.activate_study_case(path)\nActivate study case under path.\n\n\n\nactive_project_interface.PFActiveProject.add_results_variable(obj, variables, results_obj=None)\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\nArgs:\nobj (PFGeneral | str | list[PFGeneral | str]): PF object or its path\n\nvariables (list[str]): variable names\n\nresults_obj (ElmRes, optional): Results object. Defaults to None (ElmRes from active study case is used).\nReturns: ElmRes: the results object\n\n\n\nactive_project_interface.PFActiveProject.add_variable_selection_obj_to_results_obj(name, results_obj, class_name=None, variables=[])\nAdd a varible selection object (IntMon) to a result object (ElmRes).\nArgs: name (str): Name of IntMon results_obj (ElmRes): Results object class_name (str, optional): ‘classnm’ parameter of IntMon. Defaults to None. variables (list[str], optional): ‘vars’ parameter of IntMon. Defaults to [].\nReturns: IntMon: varible selection object\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres(results_obj=None)\nClear all results variables from results object (ElmRes).\nArgs: results_obj (ElmRes, optional): Results object. Defaults to None (get elmres from study case).\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres_from_objects_with_status_deleted(results_obj=None)\nDeletes all objects from a results object (ElmRes) that have the status deleted (i.e. attribute ‘obj_id’ is deleted).\n\n\n\nactive_project_interface.PFActiveProject.create_comtrade_obj(file_path, parent_folder=None)\nAdd an IntComtrade that refers to file_path (*.cfg). The objects are stored in a folder “Comtrade” in the currently active study case, unless a parent_folder is given. A new object is only created if there exists no object yet that points to the same file (‘f_name’ attribute is the file path). The file name is used for the new object name (without the .cfg ending).\n\n\n\nactive_project_interface.PFActiveProject.create_project_version(version_name, overwrite=True)\nCreate a version of current state of the project.\nUses ‘CreateVersion’. New version will be added to top level versions folder of project.\nArgs: version_name (str): Name (loc_name) of version\noverwrite (bool, optional): Overwrite existing version with same name. Defaults to True.\n\n\n\nactive_project_interface.PFActiveProject.create_variation(name, parent_folder=None, name_expansion_stage='Expansion Stage', activationTime=0, activate=1)\nCreate variation (including one expansion stage).\nArgs: name (str): Name of variation parent_folder (str | PFGeneral, optional): Parent folder where variation is created. Defaults to None (i.e. variations folder). name_expansion_stage (str, optional): Name of. Defaults to “Expansion Stage”. activationTime (int, optional): UTC time activate (int, optional): If 1, expansion stage is activate. If 0, expansion stage is not activated. Defaults to 1.\nReturns: IntScheme: The created variation object\n\n\n\nactive_project_interface.PFActiveProject.get_active_networks(error_if_no_network_is_active=True)\nGet active networks/grids.\n\n\n\nactive_project_interface.PFActiveProject.get_active_study_case(error_if_no_active_case=True)\nGet the currently active study case. Control whether error should be raised if no case is active.\nArgs: error_if_no_active_case (bool, optional): If True, raise exception if no case is active. If False, return none. Defaults to True.\nRaises: powfacpy.PFNoActiveStudyCaseError: When no case is active.\nReturns: IntCase: The active study case | None\n\n\n\nactive_project_interface.PFActiveProject.get_active_user_folder()\nGet folder of active user.\n\n\n\nactive_project_interface.PFActiveProject.get_calc_relevant_obj(obj_str, condition=lambda x: True, error_if_non_existent=True, includeOutOfService=1, topoElementsOnly=0, bAcSchemes=0)\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\nArgs: obj_str (str): name inlcuding class of object(s) (NOT their path)\ncondition (Callable, optional): See get_obj. Defaults to lambdax:True.\n\nerror_if_non_existent (bool, optional): See get_obj. Defaults to True.\n\nFrom scripting reference:\n\nincludeOutOfService (int, optional): Flag whether to include out of service objects. Defaults to 1.\n\ntopoElementsOnly (int, optional): Flag to filter for topology relevant objects only. Defaults to 0.\n\nbAcSchemes (int, optional): Flag to include hidden objects in active schemes. Defaults to 0.\nReturns: list[PFGeneral]: Found object(s)\n\n\n\nactive_project_interface.PFActiveProject.get_events_folder_from_initial_conditions_calc()\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\nThis folder is used for the events in dynamic time domain simulation (RMS/EMT).\nReturns: IntEvt: Events folder.\n\n\n\nactive_project_interface.PFActiveProject.get_first_level_folder(folder_type)\nGet folder on first level of PF database.\nArgs: folder_type (str): The folder of the active user (‘user’) or the global library (‘global library’) can be accessed.\nRaises: TypeError: Invalid folder_tpe input\nReturns: PFGeneral: first level folder\n\n\n\nactive_project_interface.PFActiveProject.get_from_study_case(name, if_not_unique='warning', if_no_study_case='error')\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\nAdditionally, this method prints a warning or raises an exception if there is more than one object found in the study case and if no study case is activated.\nArgs: name (str): class name of the object (e.g. ‘ElmRes’), optionally preceded by an object name without wildcards and a dot (e.g. ‘All Calcualations.ElmRes’)\nif_not_unique (str, optional): Warn ('warning') or raise exception ('error') if there are more than one objets of class 'class_name'. Defaults to \"warning\".\n\nif_no_study_case (str, optional): Warn ('warning') or raise exception ('error') if no study case is active. Defaults to \"error\".\nRaises: powfacpy.PFNoActiveStudyCaseError: No study case activated TypeError: More than one object was found\nReturns: PFGeneral: Found or created object\n\n\n\nactive_project_interface.PFActiveProject.get_parameter_value_string(parameters, delimiter=' ')\nGet string with parameters and their values.\nArgs: parameters (dict): parameters (keys) and values (values) Example: {‘P’: ‘user:Psum:bus1’}\ndelimiter (str, optional): Delimiter between parameter value pairs. Defaults to \" \".\nReturns: str: parameter value string (e.g. ‘P = 2.5’)\n\n\n\nactive_project_interface.PFActiveProject.get_project_version(version_name)\nGet (previous) version of project.\nArgs: version_name (str): Name (loc_name) of version\nReturns: IntVersion | None: Version object\n\n\n\nactive_project_interface.PFActiveProject.get_results_obj_from_initial_conditions_calc()\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\nThis is the results object where results from time domain (RMS/EMT) simulation are written to.\nReturns: ElmRes: ElmRes object\n\n\n\nactive_project_interface.PFActiveProject.import_project(file_path, target_folder_in_active_user=None, keep_current_project_activated=True)\nImport a project (.pfd file)\nArgs: file_path (str): Windows path target_folder_in_active_user (str | PFGeneral | None, optional): Target folder for project import in active user. Defaults to None. keep_current_project_activated (bool, optional): If True, the initial project and study case remain active.If False, the imported project will be active after import. Defaults to True.\nReturns: IntPrj: Imported project\n\n\n\nactive_project_interface.PFActiveProject.insert_row_with_number_of_columns_in_csv_file(file_path)\nGets the number of columns of the first row in a csv file and inserts a row (first row) with this number in the first column. This is needed for ElmFile to read csv files.\n\n\n\nactive_project_interface.PFActiveProject.replace_headers_of_csv_file_with_number_of_colums(file_path)\nReplaces the first row (headers) of a csv file with its number of columns. This is needed for import of csv files to PF using ElmFile.\n\n\n\nactive_project_interface.PFActiveProject.rollback_project_to_previous_version(version_name)\nRollback to previous project version (IntVersion in versions folder).\nArgs: version_name (str): Name (loc_name) of version.\n\n\n\n\n\nactive_project_interface.PFBaseInterface(self, pf_app)\nPlease use the class PFActiveProject instead."
  },
  {
    "objectID": "docs/api/active_project_interface.html#classes",
    "href": "docs/api/active_project_interface.html#classes",
    "title": "active_project_interface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPFActiveProject\nInterface to the currently active project.\n\n\nPFBaseInterface\nPlease use the class PFActiveProject instead.\n\n\n\n\n\nactive_project_interface.PFActiveProject(self, pf_app)\nInterface to the currently active project.\n\n\n\n\n\nName\nDescription\n\n\n\n\nactivate_study_case\nActivate study case under path.\n\n\nadd_results_variable\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\n\n\nadd_variable_selection_obj_to_results_obj\nAdd a varible selection object (IntMon) to a result object (ElmRes).\n\n\nclear_elmres\nClear all results variables from results object (ElmRes).\n\n\nclear_elmres_from_objects_with_status_deleted\nDeletes all objects from a results object (ElmRes) that have the\n\n\ncreate_comtrade_obj\nAdd an IntComtrade that refers to file_path (*.cfg).\n\n\ncreate_project_version\nCreate a version of current state of the project.\n\n\ncreate_variation\nCreate variation (including one expansion stage).\n\n\nget_active_networks\nGet active networks/grids.\n\n\nget_active_study_case\nGet the currently active study case. Control whether error should be raised if no case is active.\n\n\nget_active_user_folder\nGet folder of active user.\n\n\nget_calc_relevant_obj\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\n\n\nget_events_folder_from_initial_conditions_calc\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\n\n\nget_first_level_folder\nGet folder on first level of PF database.\n\n\nget_from_study_case\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\n\n\nget_parameter_value_string\nGet string with parameters and their values.\n\n\nget_project_version\nGet (previous) version of project.\n\n\nget_results_obj_from_initial_conditions_calc\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\n\n\nimport_project\nImport a project (.pfd file)\n\n\ninsert_row_with_number_of_columns_in_csv_file\nGets the number of columns of the first row in a csv file and\n\n\nreplace_headers_of_csv_file_with_number_of_colums\nReplaces the first row (headers) of a csv file with its number of\n\n\nrollback_project_to_previous_version\nRollback to previous project version (IntVersion in versions folder).\n\n\n\n\n\nactive_project_interface.PFActiveProject.activate_study_case(path)\nActivate study case under path.\n\n\n\nactive_project_interface.PFActiveProject.add_results_variable(obj, variables, results_obj=None)\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\nArgs:\nobj (PFGeneral | str | list[PFGeneral | str]): PF object or its path\n\nvariables (list[str]): variable names\n\nresults_obj (ElmRes, optional): Results object. Defaults to None (ElmRes from active study case is used).\nReturns: ElmRes: the results object\n\n\n\nactive_project_interface.PFActiveProject.add_variable_selection_obj_to_results_obj(name, results_obj, class_name=None, variables=[])\nAdd a varible selection object (IntMon) to a result object (ElmRes).\nArgs: name (str): Name of IntMon results_obj (ElmRes): Results object class_name (str, optional): ‘classnm’ parameter of IntMon. Defaults to None. variables (list[str], optional): ‘vars’ parameter of IntMon. Defaults to [].\nReturns: IntMon: varible selection object\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres(results_obj=None)\nClear all results variables from results object (ElmRes).\nArgs: results_obj (ElmRes, optional): Results object. Defaults to None (get elmres from study case).\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres_from_objects_with_status_deleted(results_obj=None)\nDeletes all objects from a results object (ElmRes) that have the status deleted (i.e. attribute ‘obj_id’ is deleted).\n\n\n\nactive_project_interface.PFActiveProject.create_comtrade_obj(file_path, parent_folder=None)\nAdd an IntComtrade that refers to file_path (*.cfg). The objects are stored in a folder “Comtrade” in the currently active study case, unless a parent_folder is given. A new object is only created if there exists no object yet that points to the same file (‘f_name’ attribute is the file path). The file name is used for the new object name (without the .cfg ending).\n\n\n\nactive_project_interface.PFActiveProject.create_project_version(version_name, overwrite=True)\nCreate a version of current state of the project.\nUses ‘CreateVersion’. New version will be added to top level versions folder of project.\nArgs: version_name (str): Name (loc_name) of version\noverwrite (bool, optional): Overwrite existing version with same name. Defaults to True.\n\n\n\nactive_project_interface.PFActiveProject.create_variation(name, parent_folder=None, name_expansion_stage='Expansion Stage', activationTime=0, activate=1)\nCreate variation (including one expansion stage).\nArgs: name (str): Name of variation parent_folder (str | PFGeneral, optional): Parent folder where variation is created. Defaults to None (i.e. variations folder). name_expansion_stage (str, optional): Name of. Defaults to “Expansion Stage”. activationTime (int, optional): UTC time activate (int, optional): If 1, expansion stage is activate. If 0, expansion stage is not activated. Defaults to 1.\nReturns: IntScheme: The created variation object\n\n\n\nactive_project_interface.PFActiveProject.get_active_networks(error_if_no_network_is_active=True)\nGet active networks/grids.\n\n\n\nactive_project_interface.PFActiveProject.get_active_study_case(error_if_no_active_case=True)\nGet the currently active study case. Control whether error should be raised if no case is active.\nArgs: error_if_no_active_case (bool, optional): If True, raise exception if no case is active. If False, return none. Defaults to True.\nRaises: powfacpy.PFNoActiveStudyCaseError: When no case is active.\nReturns: IntCase: The active study case | None\n\n\n\nactive_project_interface.PFActiveProject.get_active_user_folder()\nGet folder of active user.\n\n\n\nactive_project_interface.PFActiveProject.get_calc_relevant_obj(obj_str, condition=lambda x: True, error_if_non_existent=True, includeOutOfService=1, topoElementsOnly=0, bAcSchemes=0)\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\nArgs: obj_str (str): name inlcuding class of object(s) (NOT their path)\ncondition (Callable, optional): See get_obj. Defaults to lambdax:True.\n\nerror_if_non_existent (bool, optional): See get_obj. Defaults to True.\n\nFrom scripting reference:\n\nincludeOutOfService (int, optional): Flag whether to include out of service objects. Defaults to 1.\n\ntopoElementsOnly (int, optional): Flag to filter for topology relevant objects only. Defaults to 0.\n\nbAcSchemes (int, optional): Flag to include hidden objects in active schemes. Defaults to 0.\nReturns: list[PFGeneral]: Found object(s)\n\n\n\nactive_project_interface.PFActiveProject.get_events_folder_from_initial_conditions_calc()\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\nThis folder is used for the events in dynamic time domain simulation (RMS/EMT).\nReturns: IntEvt: Events folder.\n\n\n\nactive_project_interface.PFActiveProject.get_first_level_folder(folder_type)\nGet folder on first level of PF database.\nArgs: folder_type (str): The folder of the active user (‘user’) or the global library (‘global library’) can be accessed.\nRaises: TypeError: Invalid folder_tpe input\nReturns: PFGeneral: first level folder\n\n\n\nactive_project_interface.PFActiveProject.get_from_study_case(name, if_not_unique='warning', if_no_study_case='error')\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\nAdditionally, this method prints a warning or raises an exception if there is more than one object found in the study case and if no study case is activated.\nArgs: name (str): class name of the object (e.g. ‘ElmRes’), optionally preceded by an object name without wildcards and a dot (e.g. ‘All Calcualations.ElmRes’)\nif_not_unique (str, optional): Warn ('warning') or raise exception ('error') if there are more than one objets of class 'class_name'. Defaults to \"warning\".\n\nif_no_study_case (str, optional): Warn ('warning') or raise exception ('error') if no study case is active. Defaults to \"error\".\nRaises: powfacpy.PFNoActiveStudyCaseError: No study case activated TypeError: More than one object was found\nReturns: PFGeneral: Found or created object\n\n\n\nactive_project_interface.PFActiveProject.get_parameter_value_string(parameters, delimiter=' ')\nGet string with parameters and their values.\nArgs: parameters (dict): parameters (keys) and values (values) Example: {‘P’: ‘user:Psum:bus1’}\ndelimiter (str, optional): Delimiter between parameter value pairs. Defaults to \" \".\nReturns: str: parameter value string (e.g. ‘P = 2.5’)\n\n\n\nactive_project_interface.PFActiveProject.get_project_version(version_name)\nGet (previous) version of project.\nArgs: version_name (str): Name (loc_name) of version\nReturns: IntVersion | None: Version object\n\n\n\nactive_project_interface.PFActiveProject.get_results_obj_from_initial_conditions_calc()\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\nThis is the results object where results from time domain (RMS/EMT) simulation are written to.\nReturns: ElmRes: ElmRes object\n\n\n\nactive_project_interface.PFActiveProject.import_project(file_path, target_folder_in_active_user=None, keep_current_project_activated=True)\nImport a project (.pfd file)\nArgs: file_path (str): Windows path target_folder_in_active_user (str | PFGeneral | None, optional): Target folder for project import in active user. Defaults to None. keep_current_project_activated (bool, optional): If True, the initial project and study case remain active.If False, the imported project will be active after import. Defaults to True.\nReturns: IntPrj: Imported project\n\n\n\nactive_project_interface.PFActiveProject.insert_row_with_number_of_columns_in_csv_file(file_path)\nGets the number of columns of the first row in a csv file and inserts a row (first row) with this number in the first column. This is needed for ElmFile to read csv files.\n\n\n\nactive_project_interface.PFActiveProject.replace_headers_of_csv_file_with_number_of_colums(file_path)\nReplaces the first row (headers) of a csv file with its number of columns. This is needed for import of csv files to PF using ElmFile.\n\n\n\nactive_project_interface.PFActiveProject.rollback_project_to_previous_version(version_name)\nRollback to previous project version (IntVersion in versions folder).\nArgs: version_name (str): Name (loc_name) of version.\n\n\n\n\n\nactive_project_interface.PFBaseInterface(self, pf_app)\nPlease use the class PFActiveProject instead."
  },
  {
    "objectID": "docs/api/active_project_interface.PFActiveProject.html",
    "href": "docs/api/active_project_interface.PFActiveProject.html",
    "title": "active_project_interface.PFActiveProject",
    "section": "",
    "text": "active_project_interface.PFActiveProject(self, pf_app)\nInterface to the currently active project.\n\n\n\n\n\nName\nDescription\n\n\n\n\nactivate_study_case\nActivate study case under path.\n\n\nadd_results_variable\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\n\n\nadd_variable_selection_obj_to_results_obj\nAdd a varible selection object (IntMon) to a result object (ElmRes).\n\n\nclear_elmres\nClear all results variables from results object (ElmRes).\n\n\nclear_elmres_from_objects_with_status_deleted\nDeletes all objects from a results object (ElmRes) that have the\n\n\ncreate_comtrade_obj\nAdd an IntComtrade that refers to file_path (*.cfg).\n\n\ncreate_project_version\nCreate a version of current state of the project.\n\n\ncreate_variation\nCreate variation (including one expansion stage).\n\n\nget_active_networks\nGet active networks/grids.\n\n\nget_active_study_case\nGet the currently active study case. Control whether error should be raised if no case is active.\n\n\nget_active_user_folder\nGet folder of active user.\n\n\nget_calc_relevant_obj\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\n\n\nget_events_folder_from_initial_conditions_calc\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\n\n\nget_first_level_folder\nGet folder on first level of PF database.\n\n\nget_from_study_case\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\n\n\nget_parameter_value_string\nGet string with parameters and their values.\n\n\nget_project_version\nGet (previous) version of project.\n\n\nget_results_obj_from_initial_conditions_calc\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\n\n\nimport_project\nImport a project (.pfd file)\n\n\ninsert_row_with_number_of_columns_in_csv_file\nGets the number of columns of the first row in a csv file and\n\n\nreplace_headers_of_csv_file_with_number_of_colums\nReplaces the first row (headers) of a csv file with its number of\n\n\nrollback_project_to_previous_version\nRollback to previous project version (IntVersion in versions folder).\n\n\n\n\n\nactive_project_interface.PFActiveProject.activate_study_case(path)\nActivate study case under path.\n\n\n\nactive_project_interface.PFActiveProject.add_results_variable(obj, variables, results_obj=None)\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\nArgs:\nobj (PFGeneral | str | list[PFGeneral | str]): PF object or its path\n\nvariables (list[str]): variable names\n\nresults_obj (ElmRes, optional): Results object. Defaults to None (ElmRes from active study case is used).\nReturns: ElmRes: the results object\n\n\n\nactive_project_interface.PFActiveProject.add_variable_selection_obj_to_results_obj(name, results_obj, class_name=None, variables=[])\nAdd a varible selection object (IntMon) to a result object (ElmRes).\nArgs: name (str): Name of IntMon results_obj (ElmRes): Results object class_name (str, optional): ‘classnm’ parameter of IntMon. Defaults to None. variables (list[str], optional): ‘vars’ parameter of IntMon. Defaults to [].\nReturns: IntMon: varible selection object\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres(results_obj=None)\nClear all results variables from results object (ElmRes).\nArgs: results_obj (ElmRes, optional): Results object. Defaults to None (get elmres from study case).\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres_from_objects_with_status_deleted(results_obj=None)\nDeletes all objects from a results object (ElmRes) that have the status deleted (i.e. attribute ‘obj_id’ is deleted).\n\n\n\nactive_project_interface.PFActiveProject.create_comtrade_obj(file_path, parent_folder=None)\nAdd an IntComtrade that refers to file_path (*.cfg). The objects are stored in a folder “Comtrade” in the currently active study case, unless a parent_folder is given. A new object is only created if there exists no object yet that points to the same file (‘f_name’ attribute is the file path). The file name is used for the new object name (without the .cfg ending).\n\n\n\nactive_project_interface.PFActiveProject.create_project_version(version_name, overwrite=True)\nCreate a version of current state of the project.\nUses ‘CreateVersion’. New version will be added to top level versions folder of project.\nArgs: version_name (str): Name (loc_name) of version\noverwrite (bool, optional): Overwrite existing version with same name. Defaults to True.\n\n\n\nactive_project_interface.PFActiveProject.create_variation(name, parent_folder=None, name_expansion_stage='Expansion Stage', activationTime=0, activate=1)\nCreate variation (including one expansion stage).\nArgs: name (str): Name of variation parent_folder (str | PFGeneral, optional): Parent folder where variation is created. Defaults to None (i.e. variations folder). name_expansion_stage (str, optional): Name of. Defaults to “Expansion Stage”. activationTime (int, optional): UTC time activate (int, optional): If 1, expansion stage is activate. If 0, expansion stage is not activated. Defaults to 1.\nReturns: IntScheme: The created variation object\n\n\n\nactive_project_interface.PFActiveProject.get_active_networks(error_if_no_network_is_active=True)\nGet active networks/grids.\n\n\n\nactive_project_interface.PFActiveProject.get_active_study_case(error_if_no_active_case=True)\nGet the currently active study case. Control whether error should be raised if no case is active.\nArgs: error_if_no_active_case (bool, optional): If True, raise exception if no case is active. If False, return none. Defaults to True.\nRaises: powfacpy.PFNoActiveStudyCaseError: When no case is active.\nReturns: IntCase: The active study case | None\n\n\n\nactive_project_interface.PFActiveProject.get_active_user_folder()\nGet folder of active user.\n\n\n\nactive_project_interface.PFActiveProject.get_calc_relevant_obj(obj_str, condition=lambda x: True, error_if_non_existent=True, includeOutOfService=1, topoElementsOnly=0, bAcSchemes=0)\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\nArgs: obj_str (str): name inlcuding class of object(s) (NOT their path)\ncondition (Callable, optional): See get_obj. Defaults to lambdax:True.\n\nerror_if_non_existent (bool, optional): See get_obj. Defaults to True.\n\nFrom scripting reference:\n\nincludeOutOfService (int, optional): Flag whether to include out of service objects. Defaults to 1.\n\ntopoElementsOnly (int, optional): Flag to filter for topology relevant objects only. Defaults to 0.\n\nbAcSchemes (int, optional): Flag to include hidden objects in active schemes. Defaults to 0.\nReturns: list[PFGeneral]: Found object(s)\n\n\n\nactive_project_interface.PFActiveProject.get_events_folder_from_initial_conditions_calc()\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\nThis folder is used for the events in dynamic time domain simulation (RMS/EMT).\nReturns: IntEvt: Events folder.\n\n\n\nactive_project_interface.PFActiveProject.get_first_level_folder(folder_type)\nGet folder on first level of PF database.\nArgs: folder_type (str): The folder of the active user (‘user’) or the global library (‘global library’) can be accessed.\nRaises: TypeError: Invalid folder_tpe input\nReturns: PFGeneral: first level folder\n\n\n\nactive_project_interface.PFActiveProject.get_from_study_case(name, if_not_unique='warning', if_no_study_case='error')\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\nAdditionally, this method prints a warning or raises an exception if there is more than one object found in the study case and if no study case is activated.\nArgs: name (str): class name of the object (e.g. ‘ElmRes’), optionally preceded by an object name without wildcards and a dot (e.g. ‘All Calcualations.ElmRes’)\nif_not_unique (str, optional): Warn ('warning') or raise exception ('error') if there are more than one objets of class 'class_name'. Defaults to \"warning\".\n\nif_no_study_case (str, optional): Warn ('warning') or raise exception ('error') if no study case is active. Defaults to \"error\".\nRaises: powfacpy.PFNoActiveStudyCaseError: No study case activated TypeError: More than one object was found\nReturns: PFGeneral: Found or created object\n\n\n\nactive_project_interface.PFActiveProject.get_parameter_value_string(parameters, delimiter=' ')\nGet string with parameters and their values.\nArgs: parameters (dict): parameters (keys) and values (values) Example: {‘P’: ‘user:Psum:bus1’}\ndelimiter (str, optional): Delimiter between parameter value pairs. Defaults to \" \".\nReturns: str: parameter value string (e.g. ‘P = 2.5’)\n\n\n\nactive_project_interface.PFActiveProject.get_project_version(version_name)\nGet (previous) version of project.\nArgs: version_name (str): Name (loc_name) of version\nReturns: IntVersion | None: Version object\n\n\n\nactive_project_interface.PFActiveProject.get_results_obj_from_initial_conditions_calc()\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\nThis is the results object where results from time domain (RMS/EMT) simulation are written to.\nReturns: ElmRes: ElmRes object\n\n\n\nactive_project_interface.PFActiveProject.import_project(file_path, target_folder_in_active_user=None, keep_current_project_activated=True)\nImport a project (.pfd file)\nArgs: file_path (str): Windows path target_folder_in_active_user (str | PFGeneral | None, optional): Target folder for project import in active user. Defaults to None. keep_current_project_activated (bool, optional): If True, the initial project and study case remain active.If False, the imported project will be active after import. Defaults to True.\nReturns: IntPrj: Imported project\n\n\n\nactive_project_interface.PFActiveProject.insert_row_with_number_of_columns_in_csv_file(file_path)\nGets the number of columns of the first row in a csv file and inserts a row (first row) with this number in the first column. This is needed for ElmFile to read csv files.\n\n\n\nactive_project_interface.PFActiveProject.replace_headers_of_csv_file_with_number_of_colums(file_path)\nReplaces the first row (headers) of a csv file with its number of columns. This is needed for import of csv files to PF using ElmFile.\n\n\n\nactive_project_interface.PFActiveProject.rollback_project_to_previous_version(version_name)\nRollback to previous project version (IntVersion in versions folder).\nArgs: version_name (str): Name (loc_name) of version."
  },
  {
    "objectID": "docs/api/active_project_interface.PFActiveProject.html#methods",
    "href": "docs/api/active_project_interface.PFActiveProject.html#methods",
    "title": "active_project_interface.PFActiveProject",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nactivate_study_case\nActivate study case under path.\n\n\nadd_results_variable\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\n\n\nadd_variable_selection_obj_to_results_obj\nAdd a varible selection object (IntMon) to a result object (ElmRes).\n\n\nclear_elmres\nClear all results variables from results object (ElmRes).\n\n\nclear_elmres_from_objects_with_status_deleted\nDeletes all objects from a results object (ElmRes) that have the\n\n\ncreate_comtrade_obj\nAdd an IntComtrade that refers to file_path (*.cfg).\n\n\ncreate_project_version\nCreate a version of current state of the project.\n\n\ncreate_variation\nCreate variation (including one expansion stage).\n\n\nget_active_networks\nGet active networks/grids.\n\n\nget_active_study_case\nGet the currently active study case. Control whether error should be raised if no case is active.\n\n\nget_active_user_folder\nGet folder of active user.\n\n\nget_calc_relevant_obj\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\n\n\nget_events_folder_from_initial_conditions_calc\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\n\n\nget_first_level_folder\nGet folder on first level of PF database.\n\n\nget_from_study_case\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\n\n\nget_parameter_value_string\nGet string with parameters and their values.\n\n\nget_project_version\nGet (previous) version of project.\n\n\nget_results_obj_from_initial_conditions_calc\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\n\n\nimport_project\nImport a project (.pfd file)\n\n\ninsert_row_with_number_of_columns_in_csv_file\nGets the number of columns of the first row in a csv file and\n\n\nreplace_headers_of_csv_file_with_number_of_colums\nReplaces the first row (headers) of a csv file with its number of\n\n\nrollback_project_to_previous_version\nRollback to previous project version (IntVersion in versions folder).\n\n\n\n\n\nactive_project_interface.PFActiveProject.activate_study_case(path)\nActivate study case under path.\n\n\n\nactive_project_interface.PFActiveProject.add_results_variable(obj, variables, results_obj=None)\nAdd variable(s) of ‘obj’ to the monitored variables in of result object.\nArgs:\nobj (PFGeneral | str | list[PFGeneral | str]): PF object or its path\n\nvariables (list[str]): variable names\n\nresults_obj (ElmRes, optional): Results object. Defaults to None (ElmRes from active study case is used).\nReturns: ElmRes: the results object\n\n\n\nactive_project_interface.PFActiveProject.add_variable_selection_obj_to_results_obj(name, results_obj, class_name=None, variables=[])\nAdd a varible selection object (IntMon) to a result object (ElmRes).\nArgs: name (str): Name of IntMon results_obj (ElmRes): Results object class_name (str, optional): ‘classnm’ parameter of IntMon. Defaults to None. variables (list[str], optional): ‘vars’ parameter of IntMon. Defaults to [].\nReturns: IntMon: varible selection object\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres(results_obj=None)\nClear all results variables from results object (ElmRes).\nArgs: results_obj (ElmRes, optional): Results object. Defaults to None (get elmres from study case).\n\n\n\nactive_project_interface.PFActiveProject.clear_elmres_from_objects_with_status_deleted(results_obj=None)\nDeletes all objects from a results object (ElmRes) that have the status deleted (i.e. attribute ‘obj_id’ is deleted).\n\n\n\nactive_project_interface.PFActiveProject.create_comtrade_obj(file_path, parent_folder=None)\nAdd an IntComtrade that refers to file_path (*.cfg). The objects are stored in a folder “Comtrade” in the currently active study case, unless a parent_folder is given. A new object is only created if there exists no object yet that points to the same file (‘f_name’ attribute is the file path). The file name is used for the new object name (without the .cfg ending).\n\n\n\nactive_project_interface.PFActiveProject.create_project_version(version_name, overwrite=True)\nCreate a version of current state of the project.\nUses ‘CreateVersion’. New version will be added to top level versions folder of project.\nArgs: version_name (str): Name (loc_name) of version\noverwrite (bool, optional): Overwrite existing version with same name. Defaults to True.\n\n\n\nactive_project_interface.PFActiveProject.create_variation(name, parent_folder=None, name_expansion_stage='Expansion Stage', activationTime=0, activate=1)\nCreate variation (including one expansion stage).\nArgs: name (str): Name of variation parent_folder (str | PFGeneral, optional): Parent folder where variation is created. Defaults to None (i.e. variations folder). name_expansion_stage (str, optional): Name of. Defaults to “Expansion Stage”. activationTime (int, optional): UTC time activate (int, optional): If 1, expansion stage is activate. If 0, expansion stage is not activated. Defaults to 1.\nReturns: IntScheme: The created variation object\n\n\n\nactive_project_interface.PFActiveProject.get_active_networks(error_if_no_network_is_active=True)\nGet active networks/grids.\n\n\n\nactive_project_interface.PFActiveProject.get_active_study_case(error_if_no_active_case=True)\nGet the currently active study case. Control whether error should be raised if no case is active.\nArgs: error_if_no_active_case (bool, optional): If True, raise exception if no case is active. If False, return none. Defaults to True.\nRaises: powfacpy.PFNoActiveStudyCaseError: When no case is active.\nReturns: IntCase: The active study case | None\n\n\n\nactive_project_interface.PFActiveProject.get_active_user_folder()\nGet folder of active user.\n\n\n\nactive_project_interface.PFActiveProject.get_calc_relevant_obj(obj_str, condition=lambda x: True, error_if_non_existent=True, includeOutOfService=1, topoElementsOnly=0, bAcSchemes=0)\nWraps the method ‘GetCalcRelevantObjects’ (see PF scripting reference) and adds optional arguments similar to ‘get_obj’.\nArgs: obj_str (str): name inlcuding class of object(s) (NOT their path)\ncondition (Callable, optional): See get_obj. Defaults to lambdax:True.\n\nerror_if_non_existent (bool, optional): See get_obj. Defaults to True.\n\nFrom scripting reference:\n\nincludeOutOfService (int, optional): Flag whether to include out of service objects. Defaults to 1.\n\ntopoElementsOnly (int, optional): Flag to filter for topology relevant objects only. Defaults to 0.\n\nbAcSchemes (int, optional): Flag to include hidden objects in active schemes. Defaults to 0.\nReturns: list[PFGeneral]: Found object(s)\n\n\n\nactive_project_interface.PFActiveProject.get_events_folder_from_initial_conditions_calc()\nGet events folder (IntEvt) from the initial conditions calculation object (ComInc).\nThis folder is used for the events in dynamic time domain simulation (RMS/EMT).\nReturns: IntEvt: Events folder.\n\n\n\nactive_project_interface.PFActiveProject.get_first_level_folder(folder_type)\nGet folder on first level of PF database.\nArgs: folder_type (str): The folder of the active user (‘user’) or the global library (‘global library’) can be accessed.\nRaises: TypeError: Invalid folder_tpe input\nReturns: PFGeneral: first level folder\n\n\n\nactive_project_interface.PFActiveProject.get_from_study_case(name, if_not_unique='warning', if_no_study_case='error')\nGet objects from active study case (similar to PF built-in function ‘app.GetFromStudyCase()’).\nAdditionally, this method prints a warning or raises an exception if there is more than one object found in the study case and if no study case is activated.\nArgs: name (str): class name of the object (e.g. ‘ElmRes’), optionally preceded by an object name without wildcards and a dot (e.g. ‘All Calcualations.ElmRes’)\nif_not_unique (str, optional): Warn ('warning') or raise exception ('error') if there are more than one objets of class 'class_name'. Defaults to \"warning\".\n\nif_no_study_case (str, optional): Warn ('warning') or raise exception ('error') if no study case is active. Defaults to \"error\".\nRaises: powfacpy.PFNoActiveStudyCaseError: No study case activated TypeError: More than one object was found\nReturns: PFGeneral: Found or created object\n\n\n\nactive_project_interface.PFActiveProject.get_parameter_value_string(parameters, delimiter=' ')\nGet string with parameters and their values.\nArgs: parameters (dict): parameters (keys) and values (values) Example: {‘P’: ‘user:Psum:bus1’}\ndelimiter (str, optional): Delimiter between parameter value pairs. Defaults to \" \".\nReturns: str: parameter value string (e.g. ‘P = 2.5’)\n\n\n\nactive_project_interface.PFActiveProject.get_project_version(version_name)\nGet (previous) version of project.\nArgs: version_name (str): Name (loc_name) of version\nReturns: IntVersion | None: Version object\n\n\n\nactive_project_interface.PFActiveProject.get_results_obj_from_initial_conditions_calc()\nGet results object (ElmRes) from the initial conditions calculation object (ComInc).\nThis is the results object where results from time domain (RMS/EMT) simulation are written to.\nReturns: ElmRes: ElmRes object\n\n\n\nactive_project_interface.PFActiveProject.import_project(file_path, target_folder_in_active_user=None, keep_current_project_activated=True)\nImport a project (.pfd file)\nArgs: file_path (str): Windows path target_folder_in_active_user (str | PFGeneral | None, optional): Target folder for project import in active user. Defaults to None. keep_current_project_activated (bool, optional): If True, the initial project and study case remain active.If False, the imported project will be active after import. Defaults to True.\nReturns: IntPrj: Imported project\n\n\n\nactive_project_interface.PFActiveProject.insert_row_with_number_of_columns_in_csv_file(file_path)\nGets the number of columns of the first row in a csv file and inserts a row (first row) with this number in the first column. This is needed for ElmFile to read csv files.\n\n\n\nactive_project_interface.PFActiveProject.replace_headers_of_csv_file_with_number_of_colums(file_path)\nReplaces the first row (headers) of a csv file with its number of columns. This is needed for import of csv files to PF using ElmFile.\n\n\n\nactive_project_interface.PFActiveProject.rollback_project_to_previous_version(version_name)\nRollback to previous project version (IntVersion in versions folder).\nArgs: version_name (str): Name (loc_name) of version."
  },
  {
    "objectID": "docs/api/results_interface.PFResultsInterface.html",
    "href": "docs/api/results_interface.PFResultsInterface.html",
    "title": "results_interface.PFResultsInterface",
    "section": "",
    "text": "results_interface.PFResultsInterface(self, app)\n\n\n\n\n\nName\nDescription\n\n\n\n\nexport_to_csv\nExports simulation results to csv.\n\n\nexport_to_pandas\nReturns pandas DataFrame of the simulation results in ElmRes. By default, all results variables of the first ElmRes object found in the active study case are exported. A selection of specific variables can be exported using\n\n\nget_simulation_results_from_dataframe\nGet simulation results from a DataFrame (which was created using ‘export_to_pandas’)\n\n\nreplace_object_aliases\nReplace ‘obj_name’ with correponding entry in ‘self.obj_aliases’. If no such key exists in ‘self.obj_aliases’, ‘obj_name’ is returned.\n\n\nreplace_variable_aliases\nReplace ‘var_name’ with correponding entry in ‘self.variable_aliases’. If no such key exists in ‘self.variable_aliases’, ‘var_name’ is returned.\n\n\n\n\n\nresults_interface.PFResultsInterface.export_to_csv(dir=None, file_name='results', results_obj=None, list_of_results_objs=None, elements=None, variables=None, column_separator=',', decimal_separator='.', comres_parameters={}, format_csv_file=True)\nExports simulation results to csv.\nArguments: dir: export directory, if ‘None’ the current working directory (where script is run) is used file_name: Name of target csv file results_obj: PF ElmRes or IntComtrade object, by default the first ElmRes found in the active study case is used. All variables from this object are exported. list_of_results_objs: Specify if selected variables from several results objects should be exported. Used in combination with arguments ‘elements’ and ‘variables’. Don’t specify in combination with ‘results_obj’. Note that PF (i.e. ComRes objects) does not allow the combined export from ElmRes and IntComtrade objects. elements: Specify if only selected variables from the grid elements in this list (e.g. ElmTerm etc.) should be exported. Used in combination with ‘variables’ and ‘list_of_results_objs’(several different results objects)). variables: Specify if only selected variables (e.g. “m:u”) should be exported). Used in combination with ‘elements’ and ‘list_of_results_objs’. comres_parameters: Dictionary with parameters (and values) for the comres object.\nformat_csv_file: Format csv file so there is only one row for the header (see also _format_csv_for_elmres and format_csv_for_comtrade).\nReturns: Path of csv file.\nExample (export a selection of results variables): voltage_source = pfbi.get_unique_obj(r’Network ModelData_plot_interfaceVoltage Source’) control_model = pfbi.get_unique_obj(’Network ModelData_plot_interfaceWT Control System Type 4A_A Electrical Control Model’) objects = [voltage_source, voltage_source, control_model] variables = [‘m:Qsum:bus1’, ‘m:Psum:bus1’, ‘s:Ipcmd’ ] elmres_list = [pfbi.app.GetFromStudyCase(‘ElmRes’),]*len(variables) df = pfbi.export_to_csv(list_of_results_objs = elmres_list, objects = objects, variables = variables)\n\n\n\nresults_interface.PFResultsInterface.export_to_pandas(results_obj=None, list_of_results_objs=None, elements=None, variables=None, comres_parameters={})\nReturns pandas DataFrame of the simulation results in ElmRes. By default, all results variables of the first ElmRes object found in the active study case are exported. A selection of specific variables can be exported using the optional arguments. Uses intermediate step by exporting to csv format with comres object.\nArguments: results_obj: PF ElmRes or IntComtrade object, by default the first ElmRes found in the active study case is used. All variables from this object are exported. ist_of_results_objs: Specify if selected variables from several results objects should be exported. Used in combination with arguments ‘elements’ and ‘variables’. Don’t specify in combination with ‘results_obj’. Note that PF (i.e. ComRes objects) does not allow the combined export from ElmRes and IntComtrade objects. elements: Specify if only selected variables from the grid elements in this list (e.g. ElmTerm etc.) should be exported. Used in combination with ‘variables’ and ‘list_of_results_objs’(several different results objects)). variables: Specify if only selected variables (e.g. “m:u”) should be exported). Used in combination with ‘elements’ and ‘list_of_results_objs’. comres_parameters: Dictionary with parameters (and values) for the comres object (for intermediate step to export to csv).\nExample (export a selection of results variables): voltage_source = pfri.get_unique_obj(’Network ModelData_plot_interfaceVoltage Source’) control_model = pfri.get_unique_obj(’Network ModelData_plot_interfaceWT Control System Type 4A_A Electrical Control Model’) elements = [voltage_source, voltage_source, control_model] variables = [‘m:Qsum:bus1’, ‘m:Psum:bus1’, ‘s:Ipcmd’ ] elmres_list = [pfri.app.GetFromStudyCase(‘ElmRes’),]*len(variables) df = pfri.export_to_pandas(list_of_results_objs=elmres_list, elements=elements, variables=variables)\n\n\n\nresults_interface.PFResultsInterface.get_simulation_results_from_dataframe(df, objs, variables)\nGet simulation results from a DataFrame (which was created using ‘export_to_pandas’)\nArgs:\ndf (pd.DataFrame): DataFrame with simulation results (created using 'export_to_pandas')\n\nobjs (PFGeneral | str | Iterable[PFGeneral  |  str]): objects (for which results must be contained in the 'df')\n\nvariables (str | Iterable[str]): variables (for which results must be contained in the 'df')\nReturns: DataFrame: DataFrame with specified results\n\n\n\nresults_interface.PFResultsInterface.replace_object_aliases(obj_name)\nReplace ‘obj_name’ with correponding entry in ‘self.obj_aliases’. If no such key exists in ‘self.obj_aliases’, ‘obj_name’ is returned.\nArgs: obj_name (str): Original name (key in ‘self.obj_aliases’)\nReturns: str: Replacement (value in ‘self.obj_aliases’)\n\n\n\nresults_interface.PFResultsInterface.replace_variable_aliases(var_name)\nReplace ‘var_name’ with correponding entry in ‘self.variable_aliases’. If no such key exists in ‘self.variable_aliases’, ‘var_name’ is returned.\nArgs: var_name (str): Original name (key in ‘self.variable_aliases’)\nReturns: str: Replacement (value in ‘self.variable_aliases’)"
  },
  {
    "objectID": "docs/api/results_interface.PFResultsInterface.html#methods",
    "href": "docs/api/results_interface.PFResultsInterface.html#methods",
    "title": "results_interface.PFResultsInterface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nexport_to_csv\nExports simulation results to csv.\n\n\nexport_to_pandas\nReturns pandas DataFrame of the simulation results in ElmRes. By default, all results variables of the first ElmRes object found in the active study case are exported. A selection of specific variables can be exported using\n\n\nget_simulation_results_from_dataframe\nGet simulation results from a DataFrame (which was created using ‘export_to_pandas’)\n\n\nreplace_object_aliases\nReplace ‘obj_name’ with correponding entry in ‘self.obj_aliases’. If no such key exists in ‘self.obj_aliases’, ‘obj_name’ is returned.\n\n\nreplace_variable_aliases\nReplace ‘var_name’ with correponding entry in ‘self.variable_aliases’. If no such key exists in ‘self.variable_aliases’, ‘var_name’ is returned.\n\n\n\n\n\nresults_interface.PFResultsInterface.export_to_csv(dir=None, file_name='results', results_obj=None, list_of_results_objs=None, elements=None, variables=None, column_separator=',', decimal_separator='.', comres_parameters={}, format_csv_file=True)\nExports simulation results to csv.\nArguments: dir: export directory, if ‘None’ the current working directory (where script is run) is used file_name: Name of target csv file results_obj: PF ElmRes or IntComtrade object, by default the first ElmRes found in the active study case is used. All variables from this object are exported. list_of_results_objs: Specify if selected variables from several results objects should be exported. Used in combination with arguments ‘elements’ and ‘variables’. Don’t specify in combination with ‘results_obj’. Note that PF (i.e. ComRes objects) does not allow the combined export from ElmRes and IntComtrade objects. elements: Specify if only selected variables from the grid elements in this list (e.g. ElmTerm etc.) should be exported. Used in combination with ‘variables’ and ‘list_of_results_objs’(several different results objects)). variables: Specify if only selected variables (e.g. “m:u”) should be exported). Used in combination with ‘elements’ and ‘list_of_results_objs’. comres_parameters: Dictionary with parameters (and values) for the comres object.\nformat_csv_file: Format csv file so there is only one row for the header (see also _format_csv_for_elmres and format_csv_for_comtrade).\nReturns: Path of csv file.\nExample (export a selection of results variables): voltage_source = pfbi.get_unique_obj(r’Network ModelData_plot_interfaceVoltage Source’) control_model = pfbi.get_unique_obj(’Network ModelData_plot_interfaceWT Control System Type 4A_A Electrical Control Model’) objects = [voltage_source, voltage_source, control_model] variables = [‘m:Qsum:bus1’, ‘m:Psum:bus1’, ‘s:Ipcmd’ ] elmres_list = [pfbi.app.GetFromStudyCase(‘ElmRes’),]*len(variables) df = pfbi.export_to_csv(list_of_results_objs = elmres_list, objects = objects, variables = variables)\n\n\n\nresults_interface.PFResultsInterface.export_to_pandas(results_obj=None, list_of_results_objs=None, elements=None, variables=None, comres_parameters={})\nReturns pandas DataFrame of the simulation results in ElmRes. By default, all results variables of the first ElmRes object found in the active study case are exported. A selection of specific variables can be exported using the optional arguments. Uses intermediate step by exporting to csv format with comres object.\nArguments: results_obj: PF ElmRes or IntComtrade object, by default the first ElmRes found in the active study case is used. All variables from this object are exported. ist_of_results_objs: Specify if selected variables from several results objects should be exported. Used in combination with arguments ‘elements’ and ‘variables’. Don’t specify in combination with ‘results_obj’. Note that PF (i.e. ComRes objects) does not allow the combined export from ElmRes and IntComtrade objects. elements: Specify if only selected variables from the grid elements in this list (e.g. ElmTerm etc.) should be exported. Used in combination with ‘variables’ and ‘list_of_results_objs’(several different results objects)). variables: Specify if only selected variables (e.g. “m:u”) should be exported). Used in combination with ‘elements’ and ‘list_of_results_objs’. comres_parameters: Dictionary with parameters (and values) for the comres object (for intermediate step to export to csv).\nExample (export a selection of results variables): voltage_source = pfri.get_unique_obj(’Network ModelData_plot_interfaceVoltage Source’) control_model = pfri.get_unique_obj(’Network ModelData_plot_interfaceWT Control System Type 4A_A Electrical Control Model’) elements = [voltage_source, voltage_source, control_model] variables = [‘m:Qsum:bus1’, ‘m:Psum:bus1’, ‘s:Ipcmd’ ] elmres_list = [pfri.app.GetFromStudyCase(‘ElmRes’),]*len(variables) df = pfri.export_to_pandas(list_of_results_objs=elmres_list, elements=elements, variables=variables)\n\n\n\nresults_interface.PFResultsInterface.get_simulation_results_from_dataframe(df, objs, variables)\nGet simulation results from a DataFrame (which was created using ‘export_to_pandas’)\nArgs:\ndf (pd.DataFrame): DataFrame with simulation results (created using 'export_to_pandas')\n\nobjs (PFGeneral | str | Iterable[PFGeneral  |  str]): objects (for which results must be contained in the 'df')\n\nvariables (str | Iterable[str]): variables (for which results must be contained in the 'df')\nReturns: DataFrame: DataFrame with specified results\n\n\n\nresults_interface.PFResultsInterface.replace_object_aliases(obj_name)\nReplace ‘obj_name’ with correponding entry in ‘self.obj_aliases’. If no such key exists in ‘self.obj_aliases’, ‘obj_name’ is returned.\nArgs: obj_name (str): Original name (key in ‘self.obj_aliases’)\nReturns: str: Replacement (value in ‘self.obj_aliases’)\n\n\n\nresults_interface.PFResultsInterface.replace_variable_aliases(var_name)\nReplace ‘var_name’ with correponding entry in ‘self.variable_aliases’. If no such key exists in ‘self.variable_aliases’, ‘var_name’ is returned.\nArgs: var_name (str): Original name (key in ‘self.variable_aliases’)\nReturns: str: Replacement (value in ‘self.variable_aliases’)"
  },
  {
    "objectID": "docs/api/index.html",
    "href": "docs/api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Below are the interface classes of the Powfacpy\n\n\n\nactive_project_interface.PFActiveProject\nInterface to the currently active project.\n\n\ndatabase_interface.PFDatabaseInterface\n\n\n\nplot_interface.PFPlotInterface\n\n\n\ndyn_sim_interface.PFDynSimInterface\nDynamic simulation interface\n\n\ncase_studies.PFStudyCases\n\n\n\nresults_interface.PFResultsInterface"
  },
  {
    "objectID": "docs/api/index.html#interface-classes",
    "href": "docs/api/index.html#interface-classes",
    "title": "Function reference",
    "section": "",
    "text": "Below are the interface classes of the Powfacpy\n\n\n\nactive_project_interface.PFActiveProject\nInterface to the currently active project.\n\n\ndatabase_interface.PFDatabaseInterface\n\n\n\nplot_interface.PFPlotInterface\n\n\n\ndyn_sim_interface.PFDynSimInterface\nDynamic simulation interface\n\n\ncase_studies.PFStudyCases\n\n\n\nresults_interface.PFResultsInterface"
  },
  {
    "objectID": "docs/api/case_studies.PFStudyCases.html",
    "href": "docs/api/case_studies.PFStudyCases.html",
    "title": "case_studies.PFStudyCases",
    "section": "",
    "text": "case_studies.PFStudyCases(self, app)\n\n\n\n\n\nName\nDescription\n\n\n\n\nactive_grids\nActive grids for each study case (can be multiple for each). If only one is given, the same grid is active in every case.\n\n\nadd_scenario_to_each_case\nIf True, a corresponding scenario is created for each case.\n\n\nadd_variation_to_each_case\nIf True, a corresponding variation is created for each case.\n\n\nanonymous_parameters\nParameters for which names are not used in folder/case name strings (only the parameter values are used).\n\n\nbase_study_case\nBase study case (or its path) which is copied to create the cases.\n\n\nconsecutively_number_case_names\nIf True, numbering is added to the case names.\n\n\ndelimiter\nDefault delimiter used in parameter-value strings.\n\n\nhierarchy\nHierarchy of folders (named after the parameters) where case/scenario/varaition objects are located.\n\n\nignore_parameters_that_are_none_in_names\nIf True, parameters with value None are ignored in names (of cases etc.).\n\n\nomitted_combinations\nOmitted parameter combinations (in permutation).\n\n\noverwrite_study_cases\nIf True, existing study cases are overwriten (e.g. when calling ‘create_case’ one more time with the same settings).\n\n\nparameter_paths\nDictionary with parameter names (keys) and their path.\n\n\nparameter_values\nDictionary with parameters names (keys) and lists with parameter values for each case (values).\n\n\nparent_folder_scenarios\nParent folder where scenarios are created.\n\n\nparent_folder_study_cases\nParent folder where study cases are created.\n\n\nparent_folder_variations\nParent folder where variations are created.\n\n\nstudy_cases\nList of created study case objects when calling ‘create_cases’ (read-only).\n\n\ntitle\nTitle of the case studies.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nactivate_grids\nActivate the corresponding grids of a study case.\n\n\napply_permutation\nReplaces the values in ‘parameter_values’ with the permutation of\n\n\nclear_parent_folders\nDeletes all objects in the folders returned by\n\n\ncreate_cases\nCreate study cases.\n\n\nexport_results_of_study_cases_to_csv\nExport the simulation results (ElmRes) of the study cases to csv files.\n\n\nget_case_params_value_string\nGet parameter-value string for a case\n\n\nget_folder_path\nGet folder path (inside parent folder) of a case.\n\n\nget_scenarios_parent_folder\nGet folder where scenarios are created.\n\n\nget_study_case_number\nGet the number (index) of a study case object.\n\n\nget_study_cases\nRetrieve study case objects depending on parameter values.\n\n\nget_study_cases_from_string\nThis method is another convenient way to get study cases according to conditions. The conditions are a simple lambda function argument string (see example below). This method is more convenient but less safe than ‘self.get_study_cases’ because the conditions string is evaluated and a lambda function is created from it. Using eval() statements is generally not recommended due to unforeseeable behavior.\n\n\nget_study_cases_parent_folder\nGet folder where study cases are created.\n\n\nget_value_of_all_parameters_for_case\nGet the value of all paameters for a specific study case.\n\n\nget_value_of_parameter_for_case\nGet parameter value for a certain case.\n\n\nget_variations_parent_folder\nGet folder where variations are created.\n\n\nset_parent_folders_for_cases_scenarios_variations\nSet the parent folder for the cases, scenarios and variations (if the folders don’t exist, a new folder is created).\n\n\n\n\n\ncase_studies.PFStudyCases.activate_grids(case_num)\nActivate the corresponding grids of a study case.\nIf ‘self.active_grids’ is a list/tuple, the items correspond to each study case. If multiple grids are active for a case, list/tuples can be used in the elements in ‘active_grids’. If ‘self.active_grid’ is not a list/tuple, then one grid will be used for all cases.\nThe grids can be thier paths or PF objects.\n\n\n\ncase_studies.PFStudyCases.apply_permutation(omitted_combinations=None)\nReplaces the values in ‘parameter_values’ with the permutation of their unique elements.\nUse this method if you want to create cases of the permutation of all parameters. Note that ‘parameter_values’ is changed irreversibly.\nArgs: omitted_combinations (list[dict[str, list]], optional): Parameter combinations that are omitted. Defaults to None.\nExample:\n  omitted_combinations = [\n    {\"Par 1\": [1, 0], \"Par 2\": [\"R\", \"T\"]},\n    {\"Par 3\": [2], \"Par 1\": \"all\", \"Par 4\": \"all\"},\n  ]\n  Note that the 'all' keyword is used which means that all combiations with this parameter are omitted.\n\n\n\ncase_studies.PFStudyCases.clear_parent_folders()\nDeletes all objects in the folders returned by - self.get_study_cases_parent_folder - self.get_scenarios_parent_folder - self.get_variations_parent_folder\n\n\n\ncase_studies.PFStudyCases.create_cases(reactivate_initially_activated_study_case=True)\nCreate study cases.\nOptionally create corresponding scenarios/variations (if add_scenario_to_each_case/add_variation_to_each_case is True).\nIterates through all cases and creates study cases (and folders according to ‘hierarchy’) using parameter-value strings for the study cases (and folder names).\n\n\n\ncase_studies.PFStudyCases.export_results_of_study_cases_to_csv(export_dir=None, study_cases=None, case_numbers=None, results_obj='ElmRes', results_variables=None, format_csv_file=True)\nExport the simulation results (ElmRes) of the study cases to csv files. The csv files are named according to the study case number (e.g. case0.csv, case1.csv,..) Returns the full paths of the csv files.\nArguments: - export_dir: directory for export (default is working directory) - study_cases: study case objects - case_numbers: corresponing study case numbers - results_obj: string that is used in GetFromStudyCase to get the ElmRes object (e.g.  ‘self.app.GetFromStudyCase(“ElmRes”)’ ) - results_variables: if only specific variables should be export (see also export_to_csv). By default all variables are exported. - format_csv_file: see export_to_csv\n\n\n\ncase_studies.PFStudyCases.get_case_params_value_string(case_obj_or_case_num, omitted_parameters=None, delimiter=None, equals_sign=None, anonymous_parameters=None)\nGet parameter-value string for a case\nArgs: case_obj_or_case_num (IntCase | int): study case\nomitted_parameters (list[str], optional): parameters will not be considered. Defaults to None.\n\ndelimiter (str, optional): delimiter between parameter value pairs. Defaults to None.\n\nequals_sign (str, optional): sign between parameter name and value. Defaults to None.\n\nanonymous_parameters (list[str], optional): only the value of these parameters will be added (not their name). Defaults to None.\nReturns: str: Parameters and their values\n\n\n\ncase_studies.PFStudyCases.get_folder_path(case_num)\nGet folder path (inside parent folder) of a case.\nThe path corresponds to parameter-value pairs specified in ‘self.hierarchy’.\nArgs: case_num (int): case number\nReturns: str | None: path of study case or None if there is no hierarchy\n\n\n\ncase_studies.PFStudyCases.get_scenarios_parent_folder()\nGet folder where scenarios are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.get_study_case_number(study_case)\nGet the number (index) of a study case object.\n\n\n\ncase_studies.PFStudyCases.get_study_cases(conditions, return_case_numbers=False)\nRetrieve study case objects depending on parameter values.\nExample 1: get_study_cases({“par1”: lambda x: x == 2, “par2”: lambda x: x&gt;0}) This returns the study cases for which ‘par1’ equals 2 and ‘par2’ is positive.\nExample 2 (lambda function): get_study_cases(lambda x: x[0] &gt;= 2 and x[2] == ‘A’)\nArgs: conditions (dict[str, Callable] | Callable): Either a dictionary with keys: parameter names values: Callables with boolean return value depending on parameter (key)\n  or a single Callable that accepts an iterable containing all \n    parameters.\n    Example: lambda x: x[0] &gt;= 2 and x[2] == 'A'\n\n    Note that the order of the parameters in x must be the same as the\n    order of the keys in self.parameter_values.\n\nreturn_case_numbers (bool, optional): If True, the case number are also returned. Defaults to False.\nRaises: ValueError: If ‘callable’ is invalid.\nReturns: list[IntCase] | tuple[list[IntCase], list[int]]: study case objects and case numbers (optional)\n\n\n\ncase_studies.PFStudyCases.get_study_cases_from_string(conditions, return_case_numbers=False)\nThis method is another convenient way to get study cases according to conditions. The conditions are a simple lambda function argument string (see example below). This method is more convenient but less safe than ‘self.get_study_cases’ because the conditions string is evaluated and a lambda function is created from it. Using eval() statements is generally not recommended due to unforeseeable behavior. However, for convenience, it is used here.\nArgs: conditions (str): lambda function argument string: Example: “p HV load &gt;= 2 and (control 1 == ‘A’ and control 2 != ‘S’)”\nreturn_case_numbers (bool): If True, not only study case objects, but also study case numbers (indexes) are returned as a tuple.\nReturns: list[IntCase] | tuple[list[IntCase], list[int]]: study case objects and case numbers (optional)\n\n\n\ncase_studies.PFStudyCases.get_study_cases_parent_folder()\nGet folder where study cases are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.get_value_of_all_parameters_for_case(case_obj_or_case_num)\nGet the value of all paameters for a specific study case.\nArgs: case_obj_or_case_num (IntCase | int): study case\nReturns: list[Any]: parameter values\n\n\n\ncase_studies.PFStudyCases.get_value_of_parameter_for_case(par_name, case_obj_or_case_num)\nGet parameter value for a certain case.\nNote that the values in ‘parameter_values’ can be\n\na list/tuple where each element corresponds to a case number\nor a single value which is used for all cases\n\nArgs: par_name (str): Parameter name\ncase_obj_or_case_num (IntCase | int): Either the case number (int) or\na study case PF object (then the case number/index is derived first)\nRaises: powfacpy.PFCaseStudyParameterValueDefinitionError: If a value is not defined for a certain study case\nReturns: Any: a parameter value for a certain case.\n\n\n\ncase_studies.PFStudyCases.get_variations_parent_folder()\nGet folder where variations are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.set_parent_folders_for_cases_scenarios_variations(folder_directory='')\nSet the parent folder for the cases, scenarios and variations (if the folders don’t exist, a new folder is created).\nArgs: folder_directory (str, optional): directory of folders inside study case/scenarios/variations folder of the project. If it is an empty string, the default project folders are used (e.g. app.GetProjectFolder(“study”))"
  },
  {
    "objectID": "docs/api/case_studies.PFStudyCases.html#attributes",
    "href": "docs/api/case_studies.PFStudyCases.html#attributes",
    "title": "case_studies.PFStudyCases",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nactive_grids\nActive grids for each study case (can be multiple for each). If only one is given, the same grid is active in every case.\n\n\nadd_scenario_to_each_case\nIf True, a corresponding scenario is created for each case.\n\n\nadd_variation_to_each_case\nIf True, a corresponding variation is created for each case.\n\n\nanonymous_parameters\nParameters for which names are not used in folder/case name strings (only the parameter values are used).\n\n\nbase_study_case\nBase study case (or its path) which is copied to create the cases.\n\n\nconsecutively_number_case_names\nIf True, numbering is added to the case names.\n\n\ndelimiter\nDefault delimiter used in parameter-value strings.\n\n\nhierarchy\nHierarchy of folders (named after the parameters) where case/scenario/varaition objects are located.\n\n\nignore_parameters_that_are_none_in_names\nIf True, parameters with value None are ignored in names (of cases etc.).\n\n\nomitted_combinations\nOmitted parameter combinations (in permutation).\n\n\noverwrite_study_cases\nIf True, existing study cases are overwriten (e.g. when calling ‘create_case’ one more time with the same settings).\n\n\nparameter_paths\nDictionary with parameter names (keys) and their path.\n\n\nparameter_values\nDictionary with parameters names (keys) and lists with parameter values for each case (values).\n\n\nparent_folder_scenarios\nParent folder where scenarios are created.\n\n\nparent_folder_study_cases\nParent folder where study cases are created.\n\n\nparent_folder_variations\nParent folder where variations are created.\n\n\nstudy_cases\nList of created study case objects when calling ‘create_cases’ (read-only).\n\n\ntitle\nTitle of the case studies."
  },
  {
    "objectID": "docs/api/case_studies.PFStudyCases.html#methods",
    "href": "docs/api/case_studies.PFStudyCases.html#methods",
    "title": "case_studies.PFStudyCases",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nactivate_grids\nActivate the corresponding grids of a study case.\n\n\napply_permutation\nReplaces the values in ‘parameter_values’ with the permutation of\n\n\nclear_parent_folders\nDeletes all objects in the folders returned by\n\n\ncreate_cases\nCreate study cases.\n\n\nexport_results_of_study_cases_to_csv\nExport the simulation results (ElmRes) of the study cases to csv files.\n\n\nget_case_params_value_string\nGet parameter-value string for a case\n\n\nget_folder_path\nGet folder path (inside parent folder) of a case.\n\n\nget_scenarios_parent_folder\nGet folder where scenarios are created.\n\n\nget_study_case_number\nGet the number (index) of a study case object.\n\n\nget_study_cases\nRetrieve study case objects depending on parameter values.\n\n\nget_study_cases_from_string\nThis method is another convenient way to get study cases according to conditions. The conditions are a simple lambda function argument string (see example below). This method is more convenient but less safe than ‘self.get_study_cases’ because the conditions string is evaluated and a lambda function is created from it. Using eval() statements is generally not recommended due to unforeseeable behavior.\n\n\nget_study_cases_parent_folder\nGet folder where study cases are created.\n\n\nget_value_of_all_parameters_for_case\nGet the value of all paameters for a specific study case.\n\n\nget_value_of_parameter_for_case\nGet parameter value for a certain case.\n\n\nget_variations_parent_folder\nGet folder where variations are created.\n\n\nset_parent_folders_for_cases_scenarios_variations\nSet the parent folder for the cases, scenarios and variations (if the folders don’t exist, a new folder is created).\n\n\n\n\n\ncase_studies.PFStudyCases.activate_grids(case_num)\nActivate the corresponding grids of a study case.\nIf ‘self.active_grids’ is a list/tuple, the items correspond to each study case. If multiple grids are active for a case, list/tuples can be used in the elements in ‘active_grids’. If ‘self.active_grid’ is not a list/tuple, then one grid will be used for all cases.\nThe grids can be thier paths or PF objects.\n\n\n\ncase_studies.PFStudyCases.apply_permutation(omitted_combinations=None)\nReplaces the values in ‘parameter_values’ with the permutation of their unique elements.\nUse this method if you want to create cases of the permutation of all parameters. Note that ‘parameter_values’ is changed irreversibly.\nArgs: omitted_combinations (list[dict[str, list]], optional): Parameter combinations that are omitted. Defaults to None.\nExample:\n  omitted_combinations = [\n    {\"Par 1\": [1, 0], \"Par 2\": [\"R\", \"T\"]},\n    {\"Par 3\": [2], \"Par 1\": \"all\", \"Par 4\": \"all\"},\n  ]\n  Note that the 'all' keyword is used which means that all combiations with this parameter are omitted.\n\n\n\ncase_studies.PFStudyCases.clear_parent_folders()\nDeletes all objects in the folders returned by - self.get_study_cases_parent_folder - self.get_scenarios_parent_folder - self.get_variations_parent_folder\n\n\n\ncase_studies.PFStudyCases.create_cases(reactivate_initially_activated_study_case=True)\nCreate study cases.\nOptionally create corresponding scenarios/variations (if add_scenario_to_each_case/add_variation_to_each_case is True).\nIterates through all cases and creates study cases (and folders according to ‘hierarchy’) using parameter-value strings for the study cases (and folder names).\n\n\n\ncase_studies.PFStudyCases.export_results_of_study_cases_to_csv(export_dir=None, study_cases=None, case_numbers=None, results_obj='ElmRes', results_variables=None, format_csv_file=True)\nExport the simulation results (ElmRes) of the study cases to csv files. The csv files are named according to the study case number (e.g. case0.csv, case1.csv,..) Returns the full paths of the csv files.\nArguments: - export_dir: directory for export (default is working directory) - study_cases: study case objects - case_numbers: corresponing study case numbers - results_obj: string that is used in GetFromStudyCase to get the ElmRes object (e.g.  ‘self.app.GetFromStudyCase(“ElmRes”)’ ) - results_variables: if only specific variables should be export (see also export_to_csv). By default all variables are exported. - format_csv_file: see export_to_csv\n\n\n\ncase_studies.PFStudyCases.get_case_params_value_string(case_obj_or_case_num, omitted_parameters=None, delimiter=None, equals_sign=None, anonymous_parameters=None)\nGet parameter-value string for a case\nArgs: case_obj_or_case_num (IntCase | int): study case\nomitted_parameters (list[str], optional): parameters will not be considered. Defaults to None.\n\ndelimiter (str, optional): delimiter between parameter value pairs. Defaults to None.\n\nequals_sign (str, optional): sign between parameter name and value. Defaults to None.\n\nanonymous_parameters (list[str], optional): only the value of these parameters will be added (not their name). Defaults to None.\nReturns: str: Parameters and their values\n\n\n\ncase_studies.PFStudyCases.get_folder_path(case_num)\nGet folder path (inside parent folder) of a case.\nThe path corresponds to parameter-value pairs specified in ‘self.hierarchy’.\nArgs: case_num (int): case number\nReturns: str | None: path of study case or None if there is no hierarchy\n\n\n\ncase_studies.PFStudyCases.get_scenarios_parent_folder()\nGet folder where scenarios are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.get_study_case_number(study_case)\nGet the number (index) of a study case object.\n\n\n\ncase_studies.PFStudyCases.get_study_cases(conditions, return_case_numbers=False)\nRetrieve study case objects depending on parameter values.\nExample 1: get_study_cases({“par1”: lambda x: x == 2, “par2”: lambda x: x&gt;0}) This returns the study cases for which ‘par1’ equals 2 and ‘par2’ is positive.\nExample 2 (lambda function): get_study_cases(lambda x: x[0] &gt;= 2 and x[2] == ‘A’)\nArgs: conditions (dict[str, Callable] | Callable): Either a dictionary with keys: parameter names values: Callables with boolean return value depending on parameter (key)\n  or a single Callable that accepts an iterable containing all \n    parameters.\n    Example: lambda x: x[0] &gt;= 2 and x[2] == 'A'\n\n    Note that the order of the parameters in x must be the same as the\n    order of the keys in self.parameter_values.\n\nreturn_case_numbers (bool, optional): If True, the case number are also returned. Defaults to False.\nRaises: ValueError: If ‘callable’ is invalid.\nReturns: list[IntCase] | tuple[list[IntCase], list[int]]: study case objects and case numbers (optional)\n\n\n\ncase_studies.PFStudyCases.get_study_cases_from_string(conditions, return_case_numbers=False)\nThis method is another convenient way to get study cases according to conditions. The conditions are a simple lambda function argument string (see example below). This method is more convenient but less safe than ‘self.get_study_cases’ because the conditions string is evaluated and a lambda function is created from it. Using eval() statements is generally not recommended due to unforeseeable behavior. However, for convenience, it is used here.\nArgs: conditions (str): lambda function argument string: Example: “p HV load &gt;= 2 and (control 1 == ‘A’ and control 2 != ‘S’)”\nreturn_case_numbers (bool): If True, not only study case objects, but also study case numbers (indexes) are returned as a tuple.\nReturns: list[IntCase] | tuple[list[IntCase], list[int]]: study case objects and case numbers (optional)\n\n\n\ncase_studies.PFStudyCases.get_study_cases_parent_folder()\nGet folder where study cases are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.get_value_of_all_parameters_for_case(case_obj_or_case_num)\nGet the value of all paameters for a specific study case.\nArgs: case_obj_or_case_num (IntCase | int): study case\nReturns: list[Any]: parameter values\n\n\n\ncase_studies.PFStudyCases.get_value_of_parameter_for_case(par_name, case_obj_or_case_num)\nGet parameter value for a certain case.\nNote that the values in ‘parameter_values’ can be\n\na list/tuple where each element corresponds to a case number\nor a single value which is used for all cases\n\nArgs: par_name (str): Parameter name\ncase_obj_or_case_num (IntCase | int): Either the case number (int) or\na study case PF object (then the case number/index is derived first)\nRaises: powfacpy.PFCaseStudyParameterValueDefinitionError: If a value is not defined for a certain study case\nReturns: Any: a parameter value for a certain case.\n\n\n\ncase_studies.PFStudyCases.get_variations_parent_folder()\nGet folder where variations are created.\nReturns: IntFolder | IntPrjfolder: folder\n\n\n\ncase_studies.PFStudyCases.set_parent_folders_for_cases_scenarios_variations(folder_directory='')\nSet the parent folder for the cases, scenarios and variations (if the folders don’t exist, a new folder is created).\nArgs: folder_directory (str, optional): directory of folders inside study case/scenarios/variations folder of the project. If it is an empty string, the default project folders are used (e.g. app.GetProjectFolder(“study”))"
  },
  {
    "objectID": "docs/home/index.html",
    "href": "docs/home/index.html",
    "title": "POWFACPY",
    "section": "",
    "text": "powfacpy is a wrapper around the Python API of PowerFactory |copy| (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory |copy| with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory |copy| database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\n   set_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path “Network Mod…”.\nPlotting also requires many lines with the native API (need to add the variable to the monitored variables, create a plot page, add the curve,..). However, using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\n   set_active_plot(\"Active power\",\"§ PV plant\")\n   plot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the :ref:tutorials or see a list of classes and methods under :ref:api.\nThe module is at an early stage. Contributions (new features, bug reports, feature requests, etc.) are very welcome on Github.",
    "crumbs": [
      "Home",
      "POWFACPY"
    ]
  },
  {
    "objectID": "docs/home/index.html#introduction",
    "href": "docs/home/index.html#introduction",
    "title": "POWFACPY",
    "section": "",
    "text": "powfacpy is a wrapper around the Python API of PowerFactory |copy| (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory |copy| with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory |copy| database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\n   set_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path “Network Mod…”.\nPlotting also requires many lines with the native API (need to add the variable to the monitored variables, create a plot page, add the curve,..). However, using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\n   set_active_plot(\"Active power\",\"§ PV plant\")\n   plot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the :ref:tutorials or see a list of classes and methods under :ref:api.\nThe module is at an early stage. Contributions (new features, bug reports, feature requests, etc.) are very welcome on Github.",
    "crumbs": [
      "Home",
      "POWFACPY"
    ]
  },
  {
    "objectID": "docs/home/index.html#installation",
    "href": "docs/home/index.html#installation",
    "title": "POWFACPY",
    "section": "Installation",
    "text": "Installation\nUsing pip:\n   pip install powfacpy",
    "crumbs": [
      "Home",
      "POWFACPY"
    ]
  },
  {
    "objectID": "docs/home/index.html#contact",
    "href": "docs/home/index.html#contact",
    "title": "POWFACPY",
    "section": "Contact",
    "text": "Contact\nsimon.eberlein@iee.fraunhofer.de",
    "crumbs": [
      "Home",
      "POWFACPY"
    ]
  },
  {
    "objectID": "docs/home/index.html#about",
    "href": "docs/home/index.html#about",
    "title": "POWFACPY",
    "section": "About",
    "text": "About\nThis module is under active development.\npowfacpy is an open source module which is mainly developed at Fraunhofer IEE and not associated with DIgSILENT.",
    "crumbs": [
      "Home",
      "POWFACPY"
    ]
  },
  {
    "objectID": "docs/tutorials/getting_started.html",
    "href": "docs/tutorials/getting_started.html",
    "title": "Getting Started with Powfacpy",
    "section": "",
    "text": "This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n\nCode\n# If you use IPython/Jupyter:\nimport sys\nsys.path.append(r'C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.10') # you may use a different directory\n# Get the PF app\nimport powerfactory\napp = powerfactory.GetApplication()\n\n\nThen import powfacpy and create an instance of class PFBaseInterface (with argument app). This interface class is used mainly to interact with the PowerFactory database as we will see below.\n\n\nCode\nimport powfacpy\npfbi = powfacpy.PFBaseInterface(app)\n\n\nNote that pfbi has an attribute app that can be used similar to the app variable we loaded from the powerfactory module before. Here are two ways to 1. show the PowerFactory application and 2. activate a project:\n\n\nCode\napp.Show()\napp.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path. \n\npfbi.app.Show()\npfbi.app.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path.\n\n\nSo where does pfbi differ from the Python interface that app provides? Let’s see.",
    "crumbs": [
      "Tutorials",
      "Getting Started with Powfacpy"
    ]
  },
  {
    "objectID": "docs/tutorials/getting_started.html#introduction",
    "href": "docs/tutorials/getting_started.html#introduction",
    "title": "Getting Started with Powfacpy",
    "section": "",
    "text": "This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n\nCode\n# If you use IPython/Jupyter:\nimport sys\nsys.path.append(r'C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.10') # you may use a different directory\n# Get the PF app\nimport powerfactory\napp = powerfactory.GetApplication()\n\n\nThen import powfacpy and create an instance of class PFBaseInterface (with argument app). This interface class is used mainly to interact with the PowerFactory database as we will see below.\n\n\nCode\nimport powfacpy\npfbi = powfacpy.PFBaseInterface(app)\n\n\nNote that pfbi has an attribute app that can be used similar to the app variable we loaded from the powerfactory module before. Here are two ways to 1. show the PowerFactory application and 2. activate a project:\n\n\nCode\napp.Show()\napp.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path. \n\npfbi.app.Show()\npfbi.app.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path.\n\n\nSo where does pfbi differ from the Python interface that app provides? Let’s see.",
    "crumbs": [
      "Tutorials",
      "Getting Started with Powfacpy"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html",
    "href": "docs/tutorials/simulation_and_plotting.html",
    "title": "Dynamic Simulation and plotting",
    "section": "",
    "text": "The following tutorial introduces dynamic simulations (RMS/EMT), plotting and exporting of results (to pandas or csv) using powfacpy.\nLet’s again set up PowerFactory and create an instance of the class PFPlotInterface. This class inherits from PFBaseInterface (so those methods are available).\nCode\n# If you use IPython/Jupyter:\nimport sys\nsys.path.append(r'C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP3\\Python\\3.10') # you may use a different directory\n# Get the PF app\nimport powerfactory\napp = powerfactory.GetApplication()\nsys.path.insert(0,r'D:\\User\\seberlein\\Code\\powfacpy\\src') \nimport powfacpy\napp.Show()\napp.ActivateProject(r\"powfacpy\\powfacpy_tests\") # You may change the project path.\n# Make sure the path starts with \"\\\"\npfpi = powfacpy.PFPlotInterface(app)\npfpi.activate_study_case(r\"Study Cases\\test_plot_interface\\Study Case 1\")",
    "crumbs": [
      "Tutorials",
      "Dynamic Simulation and plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#to-pandas-dataframe",
    "href": "docs/tutorials/simulation_and_plotting.html#to-pandas-dataframe",
    "title": "Dynamic Simulation and plotting",
    "section": "To Pandas DataFrame",
    "text": "To Pandas DataFrame\nSimulation results can be exported to a Pandas DataFrame.\n\n\nCode\npfds.initialize_and_run_sim()\ndf = pfri.export_to_pandas()\ndf.head(2)\n\n\nAs can be seen, the full variable names (incl. the path of the object) as given by PowerFactory are used in the header. To omit the path use:\n\n\nCode\ndf.columns = [column_name.split('\\\\')[-1] for column_name in df.columns]\ndf.head(2)\n\n\nBy default, export_to_pandas exports all monitored variables of the first ElmRes object found in the active study case. Alternatively, network elements and the respective variables as well as results objects (ElmRes) can be specified as lists:\n\n\nCode\nvoltage_source = pfri.get_unique_obj(r'Network Model\\Network Data\\test_plot_interface\\Grid 1\\AC Voltage Source')\ncontrol_model = pfri.get_unique_obj(r'Network Model\\Network Data\\test_plot_interface\\Grid 1\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model')\n\nelements =   [voltage_source, voltage_source, control_model]\nvariables = ['m:Qsum:bus1',  'm:Psum:bus1',  's:Ipcmd'    ]\nelmres_list = [pfri.app.GetFromStudyCase('ElmRes'),]*len(variables)\n\ndf = pfri.export_to_pandas(list_of_results_objs=elmres_list, \n                           elements=elements, \n                           variables=variables)\ndf.columns = ['time', 'Q', 'P', 'Ip']\ndf.head(2)\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(ncols=2, sharex=True, sharey=True)\nax[0].plot(df.time, df.Q)\nax[0].plot(df.time, df.P)\nax[1].plot(df.time, df.Ip)",
    "crumbs": [
      "Tutorials",
      "Dynamic Simulation and plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#to-csv-file",
    "href": "docs/tutorials/simulation_and_plotting.html#to-csv-file",
    "title": "Dynamic Simulation and plotting",
    "section": "To CSV file",
    "text": "To CSV file\nWe can also export simulation results from PowerFactory to a csv file. The syntax is very simlar to the export to pandas:\n\n\nCode\npfri.export_to_csv()\n\n\nThis exports all variables from the first result object (ElmRes) found in the active study case to the directory from where the script is run. You can also specifiy a directory, a file name (default is “results”) and lists for grid objects, variables and results objects (similar to the method export_to_pandas).\n\n\nCode\nvoltage_source = pfri.get_unique_obj(r'Network Model\\Network Data\\test_plot_interface\\Grid 1\\AC Voltage Source')\ncontrol_model = pfri.get_unique_obj(r'Network Model\\Network Data\\test_plot_interface\\Grid 1\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model')\n\nelements =   [voltage_source, voltage_source, control_model]\nvariables = ['m:Qsum:bus1',  'm:Psum:bus1',  's:Ipcmd'    ]\nelmres_list = [pfri.app.GetFromStudyCase('ElmRes'),]*len(variables)\n\npfri.export_to_csv(list_of_results_objs=elmres_list, \n                   elements=elements, \n                   variables=variables)\n\n\nThe formatting of the exported csv file is as follows: the first line (header) specifies the path of the variables (object path + variable name), e.g. “Network ModelData_plot_interfaceWT Control System Type 4A_A Electrical Control Model:Iqcmd” in all columns except for the first one, which is “Time”. The remaining rows contain the values of the variables.\nThe static method plot_from_csv is used to plot from files of this format:\n\n\nCode\nplot = powfacpy.PFPlotInterface.plot_from_csv(\"results.csv\", r\"Network Model\\Network Data\"\n    r\"\\test_plot_interface\\Grid 1\\AC Voltage Source\\m:Qsum:bus1\")  \nplot = powfacpy.PFPlotInterface.plot_from_csv(\"results.csv\", r\"Network Model\\Network Data\"\n    r\"\\test_plot_interface\\Grid 1\\AC Voltage Source\\m:Psum:bus1\") \nplot = powfacpy.PFPlotInterface.plot_from_csv(\"results.csv\", r\"Network Model\\Network Data\"\n    r\"\\test_plot_interface\\Grid 1\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\\s:Ipcmd\")  \n\n\nPyplot is used by default, but you can specify a different plot interface using the optional argument plot_interface.",
    "crumbs": [
      "Tutorials",
      "Dynamic Simulation and plotting"
    ]
  }
]